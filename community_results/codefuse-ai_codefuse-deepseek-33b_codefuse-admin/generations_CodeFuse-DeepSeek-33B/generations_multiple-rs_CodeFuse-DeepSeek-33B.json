[["/// Check if in given vector of numbers, are any two numbers closer to each other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0, 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    for i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n            if (numbers[i] - numbers[j]).abs() < threshold {\n                return true;\n            }\n        }\n    }\n    false"], ["/// Given a positive integer n, you have to make a pile of n levels of stones.\n/// The first level has n stones.\n/// The number of stones in the next level is:\n/// - the next odd number if n is odd.\n/// - the next even number if n is even.\n/// Return the number of stones in each level in a vector, where element at index\n/// i represents the number of stones in the level (i+1).\n/// Examples:\n/// >>> make_a_pile(3)\n/// vec![3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n    let mut stones = Vec::new();\n    let mut level = n;\n    while level > 0 {\n        stones.push(level);\n        level = if n % 2 == 0 { level - 2 } else { level - 2 };\n    }\n    stones"], ["/// You will be given a string of words separated by commas or spaces. Your task is\n/// to split the string into words and return a vector of the words.\n/// For example:\n/// >>> words_string(String::from(\"Hi, my name is John\"))\n/// vec![String::from(\"Hi\"), String::from(\"my\"), String::from(\"name\"), String::from(\"is\"), String::from(\"John\")]\n/// >>> words_string(String::from(\"One, two, three, four, five, six\"))\n/// vec![String::from(\"One\"), String::from(\"two\"), String::from(\"three\"), String::from(\"four\"), String::from(\"five\"), String::from(\"six\")]\nfn words_string(s: String) -> Vec<String> {\n    s.split_whitespace().map(|x| x.to_string()).collect()"], ["/// This function takes two positive numbers x and y and returns the\n/// biggest even integer number that is in the range [x, y] inclusive. If \n/// there's no such number, then the function should return -1.\n/// For example:\n/// >>> choose_num(12, 15)\n/// 14\n/// >>> choose_num(13, 12)\n/// -1\nfn choose_num(x: isize, y: isize) -> isize {\n    if x % 2 != 0 {\n        x += 1;\n    }\n    if x > y {\n        return -1;\n    }\n    x"], ["/// Given a vector of positive integers x. return a sorted vector of all \n/// elements that hasn't any even digit.\n/// Note: Returned vector should be sorted in increasing order.\n/// For example:\n/// >>> unique_digits(vec![15, 33, 1422, 1])\n/// vec![1, 15, 33]\n/// >>> unique_digits(vec![152, 323, 1422, 10])\n/// Vec::<isize>::new()\nfn unique_digits(x: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for num in x {\n        let mut has_even_digit = false;\n        let mut n = num;\n        while n > 0 {\n            let digit = n % 10;\n            if digit % 2 == 0 {\n                has_even_digit = true;\n                break;\n            }\n            n /= 10;\n        }\n        if !has_even_digit {\n            result.push(num);\n        }\n    }\n    result.sort();\n    result"], ["/// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n/// reverse the resulting vector, and then replace each digit by its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2, 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the vector is empty, return an empty vector:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n/// If the vector has any strange number ignore it:\n/// >>> by_length(vec![1, -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) -> Vec<String> {\n    let mut result = Vec::new();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n            result.push(i.to_string());\n        }\n    }\n    result.sort_by(|a, b| b.cmp(a));\n    result.iter_mut().for_each(|s| {\n        *s = match s.as_str() {\n            \"1\" => \"One\",\n            \"2\" => \"Two\",\n            \"3\" => \"Three\",\n            \"4\" => \"Four\",\n            \"5\" => \"Five\",\n            \"6\" => \"Six\",\n            \"7\" => \"Seven\",\n            \"8\" => \"Eight\",\n            \"9\" => \"Nine\",\n            _ => \"\",\n        }.to_string();\n    });\n    result"], ["/// Implement the function f that takes n as a parameter,\n/// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n/// or the sum of numbers from 1 to i otherwise.\n/// i starts from 1.\n/// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n/// Example:\n/// >>> f(5)\n/// vec![1, 2, 6, 24, 15]\nfn f(n: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 1..=n {\n        if i % 2 == 0 {\n            let mut factorial = 1;\n            for j in 1..=i {\n                factorial *= j;\n            }\n            result.push(factorial);\n        } else {\n            let sum = (1..=i).sum();\n            result.push(sum);\n        }\n    }\n    result"], ["/// Given a positive integer n, return a tuple that has the number of even and odd\n/// integer palindromes that fall within the range(1, n), inclusive.\n/// Example 1:\n/// >>> even_odd_palindrome(3)\n/// (1, 2)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n/// Example 2:\n/// >>> even_odd_palindrome(12)\n/// (4, 6)\n/// Explanation:\n/// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n/// Note:\n/// 1. 1 <= n <= 10^3\n/// 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize, isize) {\n    let mut even = 0;\n    let mut odd = 0;\n    for i in 1..=n {\n        let s = i.to_string();\n        if s == s.chars().rev().collect::<String>() {\n            if i % 2 == 0 {\n                even += 1;\n            } else {\n                odd += 1;\n            }\n        }\n    }\n    (even, odd)"], ["/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in arr {\n        let mut sum = 0;\n        let mut n = num;\n        if n < 0 {\n            sum += n % 10;\n            n /= 10;\n        }\n        while n != 0 {\n            sum += n % 10;\n            n /= 10;\n        }\n        if sum > 0 {\n            count += 1;\n        }\n    }\n    count"], ["/// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n/// numbers in the vector will be randomly ordered. Your task is to determine if\n/// it is possible to get a vector sorted in non-decreasing order by performing \n/// the following operation on the given vector:\n/// You are allowed to perform right shift operation any number of times.\n/// One right shift operation means shifting all elements of the vector by one\n/// position in the right direction. The last element of the vector will be moved to\n/// the starting position in the vector i.e. 0th index. \n/// If it is possible to obtain the sorted vector by performing the above operation\n/// then return true else return false.\n/// If the given vector is empty then return true.\n/// Note: The given vector is guaranteed to have unique elements.\n/// For Example:\n/// >>> move_one_ball(vec![3, 4, 5, 1, 2])\n/// true\n/// Explanation: By performin 2 right shift operations, non-decreasing order can\n/// be achieved for the given vector.\n/// >>> move_one_ball(vec![3, 5, 4, 1, 2])\n/// false\n/// Explanation:It is not possible to get non-decreasing order for the given\n/// vector by performing any number of right shift operations.\nfn move_one_ball(arr: Vec<isize>) -> bool {\n    if arr.is_empty() {\n        return true;\n    }\n    let mut sorted = arr.clone();\n    sorted.sort();\n    let mut count = 0;\n    for i in 0..arr.len() {\n        if arr[i] != sorted[i] {\n            count += 1;\n        }\n    }\n    count <= 2"], ["/// Find the shortest palindrome that begins with a supplied string.\n/// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string that is a palindrome.\n/// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n/// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n/// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n    let mut longest_palindrome = String::new();\n    let mut longest_palindrome_length = 0;\n\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n            let prefix = &string[0..i];\n            let reversed_prefix: String = prefix.chars().rev().collect();\n            let palindrome = format!(\"{}{}\", string, reversed_prefix);\n            if palindrome.len() > longest_palindrome_length {\n                longest_palindrome = palindrome;\n                longest_palindrome_length = palindrome.len();\n            }\n        }\n    }\n\n    longest_palindrome"], ["/// In this problem, you will implement a function that takes two vectors of numbers,\n/// and determines whether it is possible to perform an exchange of elements\n/// between them to make lst1 a vector of only even numbers.\n/// There is no limit on the number of exchanged elements between lst1 and lst2.\n/// If it is possible to exchange elements between the lst1 and lst2 to make\n/// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return \"NO\".\n/// For example:\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 2, 3, 4])\n/// String::from(\"YES\")\n/// >>> exchange(vec![1, 2, 3, 4], vec![1, 5, 3, 4])\n/// String::from(\"NO\")\n/// It is assumed that the input vectors will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n\n    for num in lst1 {\n        if num % 2 == 0 {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n\n    for num in lst2 {\n        if num % 2 == 0 {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n    }\n\n    if even_count == lst1.len() {\n        return String::from(\"YES\");\n    } else if odd_count == lst1.len() {\n        return String::from(\"NO\");\n    } else {\n        return String::from(\"YES\");\n    }"], ["use std::collections::HashMap;\n\n/// Given a string representing a space separated lowercase letters, return a HashMap\n/// of the letter with the most repetition and containing the corresponding count.\n/// If several letters have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize> {\n    let mut map = HashMap::new();\n    let mut max_count = 0;\n    for word in test.split_whitespace() {\n        let count = map.entry(word.to_string()).or_insert(0);\n        *count += 1;\n        if *count > max_count {\n            max_count = *count;\n        }\n    }\n    let mut result = HashMap::new();\n    for (key, value) in map {\n        if value == max_count {\n            result.insert(key, value);\n        }\n    }\n    result"], ["/// Task\n/// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n/// then check if the result string is palindrome.\n/// A string is called palindrome if it reads the same backward as forward.\n/// You should return a tuple containing the result string and true/false for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>> reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result == result.chars().rev().collect::<String>();\n    (result, is_palindrome)"], ["/// Given a vector of strings, where each string consists of only digits, return a vector.\n/// Each element i of the output should be \"the number of odd elements in the\n/// string i of the input.\" where all the i's should be replaced by the number\n/// of odd digits in the i'th string of the input.\n/// >>> odd_count(vec![String::from(\"1234567\")])\n/// vec![String::from(\"the number of odd elements 4n the str4ng 4 of the 4nput.\")]\n/// >>> odd_count(vec![String::from(\"3\"), String::from(\"11111111\")])\n/// vec![String::from(\"the number of odd elements 1n the str1ng 1 of the 1nput.\"), String::from(\"the number of odd elements 8n the str8ng 8 of the 8nput.\")]\nfn odd_count(lst: Vec<String>) -> Vec<String> {\n    lst.iter()\n        .map(|s| format!(\"the number of odd elements {}n the str{}ng {} of the {}nput.\", s.chars().filter(|&c| c.is_digit(10) && c.to_digit(10).unwrap() & 1 == 1).count(), s.len(), s.len(), s.len()))\n        .collect()"], ["/// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n/// of nums.\n/// Example\n/// >>> minSubArraySum(vec![2, 3, 4, 1, 2, 4])\n/// 1\n/// >>> minSubArraySum(vec![-1, -2, -3])\n/// -6\nfn minSubArraySum(nums: Vec<isize>) -> isize {\n    let mut min_sum = nums[0];\n    let mut cur_sum = nums[0];\n\n    for i in 1..nums.len() {\n        cur_sum = nums[i].min(cur_sum + nums[i]);\n        min_sum = min_sum.min(cur_sum);\n    }\n\n    min_sum"], ["/// You are given a rectangular grid of wells. Each row represents a single well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well has a corresponding bucket that can be used to extract water from it, \n/// and all buckets have the same capacity.\n/// Your task is to use the buckets to empty the wells.\n/// Output the number of times you need to lower the buckets.\n/// Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let mut bucket_level = capacity;\n    for row in grid {\n        for well in row {\n            if well == 1 {\n                if bucket_level == 0 {\n                    bucket_level = capacity;\n                    count += 1;\n                }\n                bucket_level -= 1;\n            }\n        }\n    }\n    count"], ["/// In this Kata, you have to sort a vector of non-negative integers according to\n/// number of ones in their binary representation in ascending order.\n/// For similar number of ones, sort based on decimal value.\n/// It must be implemented like this:\n/// >>> sort_array(vec![1, 5, 2, 3, 4])\n/// vec![1, 2, 3, 4, 5]\n/// >>> sort_array(vec![-2, -3, -4, -5, -6])\n/// vec![-6, -5, -4, -3, -2]\n/// >>> sort_array(vec![1, 0, 2, 3, 4])\n/// vec![0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()).then(a.cmp(b)));\n    arr"], ["/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut consonant_count = 0;\n\n    for c in s.chars() {\n        if c.is_alphabetic() {\n            word.push(c);\n            if ![b'a', b'e', b'i', b'o', b'u'].contains(&c.to_ascii_lowercase().unwrap()) {\n                consonant_count += 1;\n            }\n        } else {\n            if consonant_count == n {\n                result.push(word);\n            }\n            word = String::new();\n            consonant_count = 0;\n        }\n    }\n\n    if consonant_count == n {\n        result.push(word);\n    }\n\n    result"], ["/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = vec![b'a', b'e', b'i', b'o', b'u'];\n    let mut closest_vowel = b' ';\n    let mut distance = word.len();\n\n    for i in (1..word.len() - 1).rev() {\n        if !vowels.contains(&word.as_bytes()[i]) && vowels.contains(&word.as_bytes()[i + 1]) {\n            let current_distance = i + 1 - (word.len() - 1 - i);\n            if current_distance < distance {\n                distance = current_distance;\n                closest_vowel = word.as_bytes()[i + 1];\n            }\n        }\n    }\n\n    if closest_vowel != b' ' {\n        String::from_utf8(vec![closest_vowel]).unwrap()\n    } else {\n        String::new()\n    }"], ["/// You are given a vector of two strings, both strings consist of open\n/// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it is possible to concatenate the two strings in\n/// some order, that the resulting string will be good.\n/// A string S is considered to be good if and only if all parentheses in S\n/// are balanced. For example: the string '(())()' is good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\")\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>) -> String {\n    let mut count = 0;\n    for s in lst {\n        for c in s.chars() {\n            if c == '(' {\n                count += 1;\n            } else {\n                count -= 1;\n            }\n        }\n    }\n    if count == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n    }"], ["/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String, b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n        let xor = if c1 == '1' ^ c2 == '1' { '1' } else { '0' };\n        result.push(xor);\n    }\n    result"], ["/// Given a vector arr of integers and a positive integer k, return a sorted vector \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n/// >>> maximum(vec![-3, -4, 5], 3)\n/// vec![-4, -3, 5]\n/// Example 2:\n/// >>> maximum(vec![4, -4, 4], 2)\n/// vec![4, 4]\n/// Example 3:\n/// >>> maximum(vec![-3, 2, 1, 2, -1, -2, 1], 1)\n/// vec![2]\n/// Note:\n/// 1. The length of the vector will be in the range of [1, 1000].\n/// 2. The elements in the vector will be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize) -> Vec<isize> {\n    let mut arr = arr;\n    arr.sort_by(|a, b| b.cmp(a));\n    arr[0..k as usize].to_vec()"], ["/// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n/// Examples\n/// >>> solution(vec![5, 8, 7, 1])\n/// 12\n/// >>> solution(vec![3, 3, 3, 3, 3])\n/// 9\n/// >>> solution(vec![30, 13, 24, 321])\n/// 0\nfn solution(lst: Vec<isize>) -> isize {\n    lst.iter().enumerate()\n        .filter(|&(i, _)| i % 2 == 0)\n        .filter(|&(_, x)| x % 2 != 0)\n        .map(|(_, x)| x)\n        .sum()"], ["/// Given a non-empty vector of integers arr and an integer k, return\n/// the sum of the elements with at most two digits from the first k elements of arr.\n/// Example:\n/// >>> add_elements(vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4)\n/// 24\n/// Constraints:\n/// 1. 1 <= len(arr) <= 100\n/// 2. 1 <= k <= len(arr)\nfn add_elements(arr: Vec<isize>, k: isize) -> isize {\n    let mut sum = 0;\n    for i in 0..k {\n        if arr[i] < 100 {\n            sum += arr[i];\n        }\n    }\n    sum"], ["/// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n/// as follows: start with any positive integer n. Then each term is obtained from the \n/// previous term as follows: if the previous term is even, the next term is one half of \n/// the previous term. If the previous term is odd, the next term is 3 times the previous\n/// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n/// 2. returned vector sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n/// >>> get_odd_collatz(5)\n/// vec![1, 5]\nfn get_odd_collatz(n: isize) -> Vec<isize> {\n    let mut collatz_seq = vec![n];\n    let mut current = n;\n    while current != 1 {\n        if current % 2 == 0 {\n            current = current / 2;\n        } else {\n            current = 3 * current + 1;\n        }\n        collatz_seq.push(current);\n    }\n    collatz_seq.into_iter().filter(|&x| x % 2 != 0).collect::<Vec<_>>()"], ["/// You have to write a function which validates a given date string and\n/// returns true if the date is valid otherwise false.\n/// The date is valid if all of the following rules are satisfied:\n/// 1. The date string is not empty.\n/// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n/// 3. The months should not be less than 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n/// >>> valid_date(String::from(\"03-11-2000\"))\n/// true\n/// >>> valid_date(String::from(\"15-01-2012\"))\n/// false\n/// >>> valid_date(String::from(\"04-0-2040\"))\n/// false\n/// >>> valid_date(String::from(\"06-04-2020\"))\n/// true\n/// >>> valid_date(String::from(\"06/04/2020\"))\n/// false\nfn valid_date(date: String) -> bool {\n    let parts: Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n    }\n    let month = parts[0].parse::<u32>().unwrap_or(0);\n    let day = parts[1].parse::<u32>().unwrap_or(0);\n    let year = parts[2].parse::<u32>().unwrap_or(0);\n    if month < 1 || month > 12 {\n        return false;\n    }\n    if day < 1 || day > 31 {\n        return false;\n    }\n    if month == 2 {\n        if day > 29 {\n            return false;\n        }\n        if day == 29 && !(year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n            return false;\n        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n        if day > 30 {\n            return false;\n        }\n    }\n    true"], ["/// Given a vector of numbers, return whether or not they are sorted\n/// in ascending order. If vector has more than 1 duplicate of the same\n/// number, return false. Assume no negative numbers and only integers.\n/// Examples\n/// >>> is_sorted(vec![5])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5])\n/// false\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6])\n/// true\n/// >>> is_sorted(vec![1, 2, 3, 4, 5, 6, 7])\n/// true\n/// >>> is_sorted(vec![1, 3, 2, 4, 5, 6, 7])\n/// false\n/// >>> is_sorted(vec![1, 2, 2, 3, 3, 4])\n/// true\n/// >>> is_sorted(vec![1, 2, 2, 2, 3, 4])\n/// false\nfn is_sorted(lst: Vec<isize>) -> bool {\n    let mut prev = None;\n    for &x in lst.iter() {\n        if let Some(y) = prev {\n            if x <= y {\n                return false;\n            }\n        }\n        prev = Some(x);\n    }\n    true"], ["/// You are given two intervals,\n/// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed which means that the interval (start, end)\n/// includes both start and end.\n/// For each given interval, it is assumed that its start is less or equal its end.\n/// Your task is to determine whether the length of intersection of these two \n/// intervals is a prime number.\n/// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n/// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1, 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n/// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n    let length = end - start + 1;\n    if length <= 1 {\n        return String::from(\"NO\");\n    }\n    for i in 2..length {\n        if length % i == 0 {\n            return String::from(\"NO\");\n        }\n    }\n    String::from(\"YES\")"], ["/// You are given a vector arr of integers and you need to return\n/// sum of magnitudes of integers multiplied by product of all signs\n/// of each number in the vector, represented by 1, -1 or 0.\n/// Note: return None for empty arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n/// >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\nfn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n        return None;\n    }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for num in arr {\n        sum += num.abs();\n        product *= num.signum();\n    }\n\n    Some(sum * product)"], ["/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n/// each cell of the grid contains a value. Every integer in the range [1, N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You have to find the minimum path of length k in the grid. You can start\n/// from any cell, and in each step you can move to any of the neighbor cells,\n/// in other words, you can go to cells which share an edge with you current\n/// cell.\n/// Please note that a path of length k means visiting exactly k cells (not\n/// necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length k) is considered less than a path B (of length k) if\n/// after making the ordered vectors of the values on the cells that A and B go\n/// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed that the answer is unique.\n/// Return an ordered vector of the values on the cells that the minimum path go through.\n/// Examples:    \n/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n/// vec![1, 2, 1]\n/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n/// vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n    let n = grid.len();\n    let mut dp = vec![vec![vec![isize::MAX; k as usize + 1]; n]; n];\n    dp[0][0][0] = grid[0][0];\n    for i in 0..n {\n        for j in 0..n {\n            for l in 0..k as usize + 1 {\n                if i > 0 {\n                    dp[i][j][l] = dp[i][j][l].min(dp[i - 1][j][l]);\n                }\n                if j > 0 {\n                    dp[i][j][l] = dp[i][j][l].min(dp[i][j - 1][l]);\n                }\n                if l > 0 {\n                    dp[i][j][l] = dp[i][j][l].min(dp[i][j][l - 1]);\n                }\n                if dp[i][j][l] != isize::MAX {\n                    dp[i][j][l] += grid[i][j];\n                }\n            }\n        }\n    }\n    let mut path = vec![];\n    let mut i = n - 1;\n    let mut j = n - 1;\n    let mut l = k as usize;\n    while i > 0 || j > 0 {\n        if i > 0 && dp[i - 1][j][l] < dp[i][j][l] {\n            i -= 1;\n        } else if j > 0 && dp[i][j - 1][l] < dp[i][j][l] {\n            j -= 1;\n        } else {\n            l -= 1;\n        }\n        path.push(grid[i][j]);\n    }\n    path.push(grid[0][0]);\n    path.reverse();\n    path"], ["/// Out of vector of strings, return the longest one. Return the first one in case of multiple\n/// strings of the same length. Return None in case the input vector is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()"], ["/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return a vector of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(3)\n/// vec![1, 3, 2, 8]\nfn tri(n: isize) -> Vec<isize> {\n    let mut result = vec![0; (n + 1) as usize];\n    result[0] = 3;\n    for i in 1..=n {\n        if i % 2 == 0 {\n            result[i as usize] = 1 + i / 2;\n        } else {\n            result[i as usize] = result[(i - 1) as usize] + result[(i - 2) as usize] + result[(i + 1) as usize];\n        }\n    }\n    result"], ["/// Given a positive integer n, return the product of the odd digits.\n/// Return 0 if all digits are even.\n/// For example:\n/// >>> digits(1)\n/// 1\n/// >>> digits(4)\n/// 0\n/// >>> digits(235)\n/// 15\nfn digits(n: isize) -> isize {\n    let mut product = 1;\n    let mut has_odd = false;\n    let mut num = n;\n\n    while num > 0 {\n        let digit = num % 10;\n        if digit % 2 != 0 {\n            product *= digit;\n            has_odd = true;\n        }\n        num /= 10;\n    }\n\n    if has_odd { product } else { 0 }"], ["/// Create a function that takes a string as input which contains only square brackets.\n/// The function should return true if and only if there is a valid subsequence of brackets \n/// where at least one bracket in the subsequence is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"[]]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n/// false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"[[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\nfn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n            ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                stack.pop();\n            }\n            _ => return false,\n        }\n    }\n    !stack.is_empty()"], ["/// You are given a vector of numbers.\n/// You need to return the sum of squared numbers in the given vector,\n/// round each element in the vector to the upper int(Ceiling) first.\n/// Examples:\n/// >>> lst(vec![1.0, 2.0, 3.0])\n/// 14\n/// >>> lst(vec![1.0, 4.0, 9.0])\n/// 98\n/// >>> lst(vec![1.0, 3.0, 5.0, 7.0])\n/// 84\n/// >>> lst(vec![1.4, 4.2, 0.0])\n/// 29\n/// >>> lst(vec![-2.4, 1.0, 1.0])\n/// 6\nfn sum_squares(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .map(|&x| (x.ceil().powi(2) as isize))\n        .sum()"], ["/// Create a function that returns true if the last character\n/// of a given string is an alphabetical character and is not\n/// a part of a word, and false otherwise.\n/// Note: \"word\" is a group of characters separated by space.\n/// Examples:\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pie\"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e\"))\n/// true\n/// >>> check_if_last_char_is_a_letter(String::from(\"apple pi e \"))\n/// false\n/// >>> check_if_last_char_is_a_letter(String::from(\"\"))\n/// false\nfn check_if_last_char_is_a_letter(txt: String) -> bool {\n    let mut last_char = ' ';\n    let mut is_word = false;\n    for c in txt.chars() {\n        if c.is_alphabetic() {\n            last_char = c;\n            is_word = true;\n        } else if c.is_whitespace() {\n            is_word = false;\n        }\n    }\n    last_char.is_alphabetic() && !is_word"], ["/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let mut max_index = -1;\n    for i in 1..arr.len() {\n        if arr[i] <= arr[i-1] {\n            max_index = i as isize;\n        }\n    }\n    max_index"], ["/// Create a function that returns a tuple (a, b), where 'a' is\n/// the largest of negative integers, and 'b' is the smallest\n/// of positive integers in a vector.\n/// If there is no negative or positive integers, return them as None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5, 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None, None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest_negative = None;\n    let mut smallest_positive = None;\n\n    for num in lst {\n        if num < 0 {\n            if largest_negative.is_none() || num > largest_negative.unwrap() {\n                largest_negative = Some(num);\n            }\n        } else if num > 0 {\n            if smallest_positive.is_none() || num < smallest_positive.unwrap() {\n                smallest_positive = Some(num);\n            }\n        }\n    }\n\n    (largest_negative, smallest_positive)"], ["/// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n/// Example\n/// >>> is_equal_to_sum_even(4)\n/// false\n/// >>> is_equal_to_sum_even(6)\n/// false\n/// >>> is_equal_to_sum_even(8)\n/// true\nfn is_equal_to_sum_even(n: isize) -> bool {\n    if n % 2 != 0 {\n        return false;\n    }\n    let n = n / 2;\n    for i in 1..=n {\n        for j in i..=n {\n            for k in j..=n {\n                for l in k..=n {\n                    if i + j + k + l == n {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    false"], ["/// The Brazilian factorial is defined as:\n/// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n/// where n > 0\n/// For example:\n/// >>> special_factorial(4)\n/// 288\n/// The function will receive an integer as input and should return the special\n/// factorial of this integer.\nfn special_factorial(n: isize) -> isize {\n    let mut result = 1;\n    for i in 1..=n {\n        result *= (1..=i).product();\n    }\n    result"], ["/// Return a greatest common divisor of two integers a and b\n/// >>> greatest_common_divisor(3, 5)\n/// 1\n/// >>> greatest_common_divisor(25, 15)\n/// 5\nfn greatest_common_divisor(a: isize, b: isize) -> isize {\n    let mut a = a;\n    let mut b = b;\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a.abs()"], ["/// Given a string text, replace all spaces in it with underscores, \n/// and if a string has more than 2 consecutive spaces, \n/// then replace all consecutive spaces with - \n/// >>> fix_spaces(String::from(\" Example\"))\n/// String::from(\"Example\")\n/// >>> fix_spaces(String::from(\" Example 1\"))\n/// String::from(\"Example_1\")\n/// >>> fix_spaces(String::from(\" Example 2\"))\n/// String::from(\"_Example_2\")\n/// >>> fix_spaces(String::from(\" Example 3\"))\n/// String::from(\"_Example-3\")\nfn fix_spaces(text: String) -> String {\n    let mut result = String::new();\n    let mut prev_char = ' ';\n    let mut consecutive_spaces = 0;\n\n    for c in text.chars() {\n        if c == ' ' {\n            consecutive_spaces += 1;\n            if consecutive_spaces > 2 {\n                result.push('-');\n                consecutive_spaces = 0;\n            }\n        } else {\n            if prev_char == ' ' {\n                result.push('_');\n            }\n            result.push(c);\n            consecutive_spaces = 0;\n        }\n        prev_char = c;\n    }\n\n    result"], ["/// Create a function which takes a string representing a file's name, and returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n/// A file's name is considered to be valid if and only if all the following conditions \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The substring before the dot should not be empty, and it starts with a letter from \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// >>> file_name_check(String::from(\"example.txt\"))\n/// String::from(\"Yes\")\n/// >>> file_name_check(String::from(\"1example.dll\"))\n/// String::from(\"No\")\nfn file_name_check(file_name: String) -> String {\n    let mut digit_count = 0;\n    let mut dot_count = 0;\n    let mut before_dot = String::new();\n    let mut after_dot = String::new();\n\n    for c in file_name.chars() {\n        if c.is_digit() {\n            digit_count += 1;\n        } else if c == '.' {\n            dot_count += 1;\n        } else if before_dot.is_empty() {\n            before_dot.push(c);\n        } else {\n            after_dot.push(c);\n        }\n    }\n\n    if digit_count > 3 || dot_count != 1 || before_dot.is_empty() || !before_dot.chars().next().unwrap().is_alphabetic() || ![\"txt\", \"exe\", \"dll\"].contains(&after_dot) {\n        return String::from(\"No\");\n    }\n\n    String::from(\"Yes\")"], ["/// \"\n/// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n/// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n/// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n/// Examples:\n/// >>> lst\n/// vec![1, 2, 3]\n/// >>> lst\n/// vec![]\n/// >>> lst\n/// vec![-1, -5, 2, -1, -5]\nfn sum_squares(lst: Vec<isize>) -> isize {\n    let mut sum = 0;\n    for (i, &num) in lst.iter().enumerate() {\n        if i % 3 == 0 {\n            sum += num * num;\n        } else if i % 4 == 0 {\n            sum += num * num * num;\n        } else {\n            sum += num;\n        }\n    }\n    sum"], ["/// You are given a string representing a sentence,\n/// the sentence contains some words separated by a space,\n/// and you have to return a string that contains the words from the original sentence,\n/// whose lengths are prime numbers,\n/// the order of the words in the new string should be the same as the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence: String) -> String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace() {\n        if is_prime(word.len()) {\n            result.push_str(&format!(\"{} \", word));\n        }\n    }\n    result.trim().to_string()"], ["/// Your task is to implement a function that will simplify the expression\n/// x * n. The function returns true if x * n evaluates to a whole number and false\n/// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n/// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n/// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n/// >>> simplify(String::from(\"1/5\"), String::from(\"5/1\"))\n/// true\n/// >>> simplify(String::from(\"1/6\"), String::from(\"2/1\"))\n/// false\n/// >>> simplify(String::from(\"7/10\"), String::from(\"10/2\"))\n/// false\nfn simplify(x: String, n: String) -> bool {\n    let mut x_parts = x.split('/').map(|s| s.parse::<u32>().unwrap());\n    let mut n_parts = n.split('/').map(|s| s.parse::<u32>().unwrap());\n\n    let mut x_num = x_parts.next().unwrap();\n    let mut x_den = x_parts.next().unwrap();\n    let mut n_num = n_parts.next().unwrap();\n    let mut n_den = n_parts.next().unwrap();\n\n    // Multiply the numerators and denominators\n    let mut num = x_num * n_num;\n    let mut den = x_den * n_den;\n\n    // Simplify the fraction\n    let gcd = gcd(num, den);\n    num /= gcd;\n    den /= gcd;\n\n    // Check if the result is a whole number\n    num % den == 0"], ["/// Write a function which sorts the given vector of integers\n/// in ascending order according to the sum of their digits.\n/// Note: if there are several items with similar sum of their digits,\n/// order them based on their index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut nums = nums;\n    nums.sort_by_key(|&n| (n.abs().to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>(), n.abs()));\n    nums"], ["/// Write a function that takes a vector of numbers as input and returns \n/// the number of elements in the vector that are greater than 10 and both \n/// first and last digits of a number are odd (1, 3, 5, 7, 9).\n/// For example:\n/// >>> specialFilter(vec![15, -73, 14, -15])\n/// 1\n/// >>> specialFilter(vec![33, -2, -3, 45, 21, 109])\n/// 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n    let mut count = 0;\n    for num in nums {\n        if num > 10 && (num.abs() % 10) % 2 == 1 && (num.abs() / 100000000) % 2 == 1 {\n            count += 1;\n        }\n    }\n    count"], ["/// You are given a positive integer n. You have to create an integer vector a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// >>> get_max_triples(5)\n/// 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The only valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n    let mut count = 0;\n    for i in 1..=n {\n        for j in (i+1)..=n {\n            for k in (j+1)..=n {\n                let sum = i*i - i + 1 + j*j - j + 1 + k*k - k + 1;\n                if sum % 3 == 0 {\n                    count += 1;\n                }\n            }\n        }\n    }\n    count"], ["/// Write a function that accepts a vector of strings as a parameter,\n/// deletes the strings that have odd lengths from it,\n/// and returns the resulted vector with a sorted order,\n/// The vector is always a vector of strings and never a vector of numbers,\n/// and it may contain duplicates.\n/// The order of the vector should be ascending by length of each word, and you\n/// should return the vector sorted by that rule.\n/// If two words have the same length, sort the vector alphabetically.\n/// The function should return a vector of strings in sorted order.\n/// You may assume that all words will have the same length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n/// vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    let mut result = lst.into_iter()\n        .filter(|s| s.len() % 2 == 0)\n        .collect::<Vec<String>>();\n    result.sort_by(|a, b| a.len().cmp(&b.len()).then(a.cmp(b)));\n    result"], ["/// Return vector of all prefixes from shortest to longest of the input string\n/// >>> all_prefixes(String::from(\"abc\"))\n/// vec![String::from(\"a\"), String::from(\"ab\"), String::from(\"abc\")]\nfn all_prefixes(string: String) -> Vec<String> {\n    (1..=string.len()).map(|i| string[0..i].to_string()).collect()"], ["/// A simple program which should return the value of x if n is \n/// a prime number and should return the value of y otherwise.\n/// Examples:\n/// >>> x_or_y(7, 34, 12)\n/// 34\n/// >>> x_or_y(15, 8, 5)\n/// 5\nfn x_or_y(n: isize, x: isize, y: isize) -> isize {\n    if is_prime(n) {\n        return x;\n    } else {\n        return y;\n    }"], ["/// Given a vector of numbers, return the sum of squares of the numbers\n/// in the vector that are odd. Ignore numbers that are negative or not integers.\n/// >>> double_the_difference(vec![1, 3, 2, 0])\n/// 10\n/// >>> double_the_difference(vec![-1, -2, 0])\n/// 0\n/// >>> double_the_difference(vec![9, -2])\n/// 81\n/// >>> double_the_difference(vec![0])\n/// 0\n/// If the input vector is empty, return 0.\nfn double_the_difference(lst: Vec<f64>) -> isize {\n    lst.iter()\n        .filter(|&x| x.is_sign_positive() && x.fract() == 0.0)\n        .map(|&x| (x as isize).pow(2))\n        .sum()"], ["/// I think we all remember that feeling when the result of some long-awaited\n/// event is finally known. The feelings and thoughts you have at that moment are\n/// definitely worth noting down and comparing.\n/// Your task is to determine if a person correctly guessed the results of a number of matches.\n/// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n/// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n/// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n/// example:\n/// >>> compare(vec![1, 2, 3, 4, 5, 1], vec![1, 2, 3, 4, 2, -2])\n/// vec![0, 0, 0, 0, 3, 3]\n/// >>> compare(vec![0, 5, 0, 0, 0, 4], vec![4, 1, 1, 0, 0, -2])\n/// vec![4, 4, 1, 0, 0, 6]\nfn compare(game: Vec<isize>, guess: Vec<isize>) -> Vec<isize> {\n    game.iter().zip(guess.iter()).map(|(s, g)| (s - g).abs()).collect()"], ["/// You will be given the name of a class (a string) and a vector of extensions.\n/// The extensions are to be used to load additional classes to the class. The\n/// strength of the extension is as follows: Let CAP be the number of the uppercase\n/// letters in the extension's name, and let SM be the number of lowercase letters \n/// in the extension's name, the strength is given by the fraction CAP - SM. \n/// You should find the strongest extension and return a string in this \n/// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions with the same strength, you should\n/// choose the one that comes first in the vector.\n/// For example, if you are given \"Slices\" as the class and a vector of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n/// Example:\n/// >>> Strongest_Extension(String::from(\"my_class\"), vec![String::from(\"AA\"), String::from(\"Be\"), String::from(\"CC\")])\n/// String::from(\"my_class.AA\")\nfn Strongest_Extension(class_name: String, extensions: Vec<String>) -> String {\n    let mut strongest_extension = extensions[0].clone();\n    let mut strongest_strength = get_strength(&strongest_extension);\n\n    for extension in extensions.iter().skip(1) {\n        let strength = get_strength(extension);\n        if strength > strongest_strength {\n            strongest_extension = extension.clone();\n            strongest_strength = strength;\n        }\n    }\n\n    format!(\"{}.{}\", class_name, strongest_extension)"], ["/// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n/// >>> cycpattern_check(String::from(\"abcd\"), String::from(\"abd\"))\n/// false\n/// >>> cycpattern_check(String::from(\"hello\"), String::from(\"ell\"))\n/// true\n/// >>> cycpattern_check(String::from(\"whassup\"), String::from(\"psus\"))\n/// false\n/// >>> cycpattern_check(String::from(\"abab\"), String::from(\"baa\"))\n/// true\n/// >>> cycpattern_check(String::from(\"efef\"), String::from(\"eeff\"))\n/// false\n/// >>> cycpattern_check(String::from(\"himenss\"), String::from(\"simen\"))\n/// true\nfn cycpattern_check(a: String, b: String) -> bool {\n    let mut rotations = vec![b.clone()];\n    for i in 1..b.len() {\n        let mut rotation = b[i..].to_string();\n        rotation.push_str(&b[..i]);\n        rotations.push(rotation);\n    }\n    rotations.iter().any(|r| a.contains(r))"], ["/// Given an integer. return a tuple that has the number of even and odd digits respectively.\n/// Example:\n/// >>> even_odd_count(-12)\n/// (1, 1)\n/// >>> even_odd_count(123)\n/// (1, 2)\nfn even_odd_count(num: isize) -> (isize, isize) {\n    let mut even_count = 0;\n    let mut odd_count = 0;\n\n    let mut num = num.abs();\n\n    while num > 0 {\n        let digit = num % 10;\n        if digit % 2 == 0 {\n            even_count += 1;\n        } else {\n            odd_count += 1;\n        }\n        num /= 10;\n    }\n\n    (even_count, odd_count)"], ["/// Given a positive integer, obtain its roman numeral equivalent as a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n/// Examples:\n/// >>> int_to_mini_roman(19)\n/// String::from(\"xix\")\n/// >>> int_to_mini_roman(152)\n/// String::from(\"clii\")\n/// >>> int_to_mini_roman(426)\n/// String::from(\"cdxxvi\")\nfn int_to_mini_roman(number: isize) -> String {\n    let mut result = String::new();\n    let mut num = number;\n\n    while num > 0 {\n        if num >= 100 {\n            result.push_str(\"c\");\n            num -= 100;\n        } else if num >= 90 {\n            result.push_str(\"xc\");\n            num -= 90;\n        } else if num >= 50 {\n            result.push_str(\"l\");\n            num -= 50;\n        } else if num >= 40 {\n            result.push_str(\"xl\");\n            num -= 40;\n        } else if num >= 10 {\n            result.push_str(\"x\");\n            num -= 10;\n        } else if num >= 9 {\n            result.push_str(\"ix\");\n            num -= 9;\n        } else if num >= 5 {\n            result.push_str(\"v\");\n            num -= 5;\n        } else if num >= 4 {\n            result.push_str(\"iv\");\n            num -= 4;\n        } else {\n            result.push_str(\"i\");\n            num -= 1;\n        }\n    }\n\n    result.to_lowercase()"], ["/// Given the lengths of the three sides of a triangle. Return true if the three\n/// sides form a right-angled triangle, false otherwise.\n/// A right-angled triangle is a triangle in which one angle is right angle or \n/// 90 degree.\n/// Example:\n/// >>> right_angle_triangle(3, 4, 5)\n/// true\n/// >>> right_angle_triangle(1, 2, 3)\n/// false\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool {\n    let mut sides = vec![a, b, c];\n    sides.sort();\n    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]"], ["/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let mut max_word = String::new();\n    let mut max_unique_chars = 0;\n\n    for word in words {\n        let unique_chars = word.chars().collect::<HashSet<char>>().len();\n\n        if unique_chars > max_unique_chars || (unique_chars == max_unique_chars && word < max_word) {\n            max_word = word.clone();\n            max_unique_chars = unique_chars;\n        }\n    }\n\n    max_word"], ["/// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n/// you should return a vector of [ total number of eaten carrots after your meals,\n/// the number of carrots left after your meals ]\n/// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n/// >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n/// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n/// the number of carrots that you have eaten.\n/// @need : integer\n/// the number of carrots that you need to eat.\n/// @remaining : integer\n/// the number of remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let eaten = number + need;\n    let left = if remaining < need { remaining } else { remaining - need };\n    vec![eaten, left]"], ["/// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n/// >>> string_sequence(0)\n/// String::from(\"0\")\n/// >>> string_sequence(5)\n/// String::from(\"0 1 2 3 4 5\")\nfn string_sequence(n: isize) -> String {\n    (0..=n).map(|x| x.to_string()).collect::<Vec<_>>().join(\" \")"], ["/// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n/// the second vector is a vector of integers. Use the two given vectors to build the algebric \n/// expression and return the evaluation of this expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// vector = [2, 3, 4, 5]\n/// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator vector is equal to the length of operand vector minus one.\n/// Operand is a vector of of non-negative integers.\n/// Operator vector has at least one operator, and operand vector has at least two operands.\nfn do_algebra(operator: Vec<String>, operand: Vec<isize>) -> isize {\n    let mut result = operand[0];\n    for i in 1..operand.len() {\n        match operator[i - 1].as_str() {\n            \"+\" => result += operand[i],\n            \"-\" => result -= operand[i],\n            \"*\" => result *= operand[i],\n            \"//\" => result /= operand[i],\n            \"**\" => result = result.pow(operand[i] as u32),\n            _ => panic!(\"Invalid operator\"),\n        }\n    }\n    result"], ["/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n    let mut result = String::new();\n    let mut has_letter = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n            has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n            } else {\n                result.push(c.to_lowercase().next().unwrap());\n            }\n        } else {\n            result.push(c);\n        }\n    }\n    if !has_letter {\n        result = s.chars().rev().collect();\n    }\n    result"], ["/// Given a string 'text', return its md5 hash equivalent string.\n/// If 'text' is an empty string, return None.\n/// >>> string_to_md5(String::from(\"Hello world\"))\n/// Some(String::from(\"3e25960a79dbc69b674cd4ec67a72c62\"))\nfn string_to_md5(text: String) -> Option<String> {\n    if text.is_empty() {\n        None\n    } else {\n        let digest = md5::compute(text.as_bytes());\n        let mut result = String::new();\n        for &byte in digest.as_ref() {\n            result.push_str(&format!(\"{:02x}\", byte));\n        }\n        Some(result)\n    }"], ["/// Given two positive integers a and b, return the even digits between a\n/// and b, in ascending order.\n/// For example:\n/// >>> generate_integers(2, 8)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(8, 2)\n/// vec![2, 4, 6, 8]\n/// >>> generate_integers(10, 14)\n/// Vec::<isize>::new()\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current = a;\n    if a > b {\n        current = b;\n    }\n    while current <= a.max(b) {\n        if current % 2 == 0 {\n            result.push(current);\n        }\n        current += 1;\n    }\n    result"], ["/// Given a string, find out how many distinct characters (regardless of case) does it consist of\n/// >>> count_distinct_characters(String::from(\"xyzXYZ\"))\n/// 3\n/// >>> count_distinct_characters(String::from(\"Jerry\"))\n/// 4\nfn count_distinct_characters(string: String) -> isize {\n    let mut set = std::collections::HashSet::new();\n    for c in string.chars() {\n        set.insert(c.to_ascii_lowercase());\n    }\n    set.len() as isize"], ["/// Input to this function is a string representing musical notes in a special ASCII format.\n/// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n/// not last.\n/// Here is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note, lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n    let mut current_beat = 0;\n\n    for note in music_string.chars() {\n        match note {\n            'o' => {\n                current_beat += 4;\n                beats.push(current_beat);\n                current_beat = 0;\n            }\n            '|' => {\n                current_beat += 2;\n                beats.push(current_beat);\n                current_beat = 0;\n            }\n            '.' => {\n                current_beat += 1;\n                beats.push(current_beat);\n                current_beat = 0;\n            }\n            _ => {}\n        }\n    }\n\n    beats"], ["/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while let Some(i) = string[index..].find(&substring) {\n        count += 1;\n        index += i + 1;\n    }\n    count"], ["/// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n/// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n/// Return the string with numbers sorted from smallest to largest\n/// >>> sort_numbers(String::from(\"three one five\"))\n/// String::from(\"one three five\")\nfn sort_numbers(numbers: String) -> String {\n    let mut nums: Vec<&str> = numbers.split_whitespace().collect();\n    nums.sort_by(|a, b| a.cmp(b));\n    nums.join(\" \")"], ["/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n    let mut groups = Vec::new();\n    let mut current_group = String::new();\n    let mut open_count = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            open_count += 1;\n        } else if c == ')' {\n            open_count -= 1;\n        }\n\n        if open_count == 0 && !current_group.is_empty() {\n            groups.push(current_group);\n            current_group = String::new();\n        } else if c != ' ' {\n            current_group.push(c);\n        }\n    }\n\n    groups"], ["/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let mut min_diff = (closest_pair.0 - closest_pair.1).abs();\n\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff < min_diff {\n                min_diff = diff;\n                closest_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    if closest_pair.0 < closest_pair.1 {\n        closest_pair\n    } else {\n        (closest_pair.1, closest_pair.0)\n    }"], ["/// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n/// such that the smallest number will become 0 and the largest will become 1\n/// >>> rescale_to_unit(vec![1.0, 2.0, 3.0, 4.0, 5.0])\n/// vec![0.0, 0.25, 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n    let min = numbers.iter().copied().min().unwrap();\n    let max = numbers.iter().copied().max().unwrap();\n    let range = max - min;\n\n    numbers\n        .iter()\n        .map(|&x| (x - min) / range)\n        .collect()"], ["/// Return length of given string\n/// >>> strlen(String::from(\"\"))\n/// 0\n/// >>> strlen(String::from(\"abc\"))\n/// 3\nfn strlen(string: String) -> isize {\n    string.len() as isize"], ["/// For a given number n, find the largest number that divides n evenly, smaller than n\n/// >>> largest_divisor(15)\n/// 5\nfn largest_divisor(n: isize) -> isize {\n    let mut divisor = n - 1;\n    while divisor > 1 {\n        if n % divisor == 0 {\n            return divisor;\n        }\n        divisor -= 1;\n    }\n    1"], ["/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n    let mut num = n;\n    let mut divisor = 2;\n\n    while num > 1 {\n        if num % divisor == 0 {\n            factors.push(divisor);\n            num /= divisor;\n        } else {\n            divisor += 1;\n        }\n    }\n\n    factors"], ["/// From a vector of integers, remove all elements that occur more than once.\n/// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates(vec![1, 2, 3, 2, 4])\n/// vec![1, 3, 4]\nfn remove_duplicates(numbers: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for number in numbers {\n        if !result.contains(&number) {\n            result.push(number);\n        }\n    }\n    result"], ["/// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n/// >>> flip_case(String::from(\"Hello\"))\n/// String::from(\"hELLO\")\nfn flip_case(string: String) -> String {\n    string.chars().map(|c| {\n        if c.is_uppercase() {\n            c.to_lowercase()\n        } else if c.is_lowercase() {\n            c.to_uppercase()\n        } else {\n            c\n        }\n    }).collect()"], ["/// Concatenate vector of strings into a single string\n/// >>> concatenate(vec![])\n/// String::from(\"\")\n/// >>> concatenate(vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")])\n/// String::from(\"abc\")\nfn concatenate(strings: Vec<String>) -> String {\n    strings.join(\"\")"], ["/// Filter an input vector of strings only for ones that start with a given prefix.\n/// >>> filter_by_prefix(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_prefix(vec![String::from(\"abc\"), String::from(\"bcd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"array\")]\nfn filter_by_prefix(strings: Vec<String>, prefix: String) -> Vec<String> {\n    strings.into_iter().filter(|s| s.starts_with(&prefix)).collect()"], ["/// Given a positive floating point number, it can be decomposed into\n/// and integer part (largest integer smaller than given number) and decimals\n/// (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n    number - number.floor()"], ["/// Return only positive numbers in the vector.\n/// >>> get_positive(vec![-1, 2, -4, 5, 6])\n/// vec![2, 5, 6]\n/// >>> get_positive(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// vec![5, 3, 2, 3, 9, 123, 1]\nfn get_positive(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().filter(|&x| x > 0).collect()"], ["/// Return true if a given number is prime, and false otherwise.\n/// >>> is_prime(6)\n/// false\n/// >>> is_prime(101)\n/// true\n/// >>> is_prime(11)\n/// true\n/// >>> is_prime(13441)\n/// true\n/// >>> is_prime(61)\n/// true\n/// >>> is_prime(4)\n/// false\n/// >>> is_prime(1)\n/// false\nfn is_prime(n: isize) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    for i in 2..((n as f64).sqrt().ceil() as isize + 1) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n/// to the values of the corresponding indicies of l, but sorted.\n/// >>> sort_third(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_third(vec![5, 6, 3, 4, 8, 9, 2])\n/// vec![2, 6, 3, 4, 8, 9, 5]\nfn sort_third(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime = l.clone();\n    let mut divisible_by_three = Vec::new();\n    for i in 0..l.len() {\n        if i % 3 == 0 {\n            divisible_by_three.push(l[i]);\n        }\n    }\n    divisible_by_three.sort();\n    let mut j = 0;\n    for i in 0..l.len() {\n        if i % 3 == 0 {\n            l_prime[i] = divisible_by_three[j];\n            j += 1;\n        }\n    }\n    l_prime"], ["/// Return sorted unique elements in a vector\n/// >>> unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![0, 2, 3, 5, 9, 123]\nfn unique(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n    v.sort();\n    v.dedup();\n    v"], ["/// Return maximum element in the vector.\n/// >>> max_element(vec![1, 2, 3])\n/// 3\n/// >>> max_element(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n/// 123\nfn max_element(l: Vec<isize>) -> isize {\n    *l.iter().max().unwrap()"], ["/// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n/// >>> fizz_buzz(50)\n/// 0\n/// >>> fizz_buzz(78)\n/// 2\n/// >>> fizz_buzz(79)\n/// 3\nfn fizz_buzz(n: isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        if i % 11 == 0 || i % 13 == 0 {\n            let mut num = i;\n            while num > 0 {\n                if num % 10 == 7 {\n                    count += 1;\n                }\n                num /= 10;\n            }\n        }\n    }\n    count"], ["/// This function takes a vector l and returns a vector l' such that\n/// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>> sort_even(vec![1, 2, 3])\n/// vec![1, 2, 3]\n/// >>> sort_even(vec![5, 6, 3, 4])\n/// vec![3, 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_sorted = l.clone();\n    l_sorted.sort_unstable();\n    let mut l_sorted_even = Vec::new();\n    for i in (0..l.len()).step_by(2) {\n        l_sorted_even.push(l_sorted[i]);\n    }\n    let mut l_sorted_odd = Vec::new();\n    for i in (1..l.len()).step_by(2) {\n        l_sorted_odd.push(l[i]);\n    }\n    l_sorted_even.append(&mut l_sorted_odd);\n    l_sorted_even"], ["/// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n/// >>> prime_fib(1)\n/// 2\n/// >>> prime_fib(2)\n/// 3\n/// >>> prime_fib(3)\n/// 5\n/// >>> prime_fib(4)\n/// 13\n/// >>> prime_fib(5)\n/// 89\nfn prime_fib(n: isize) -> isize {\n    let mut fib_nums = vec![0, 1];\n    let mut prime_fibs = vec![];\n\n    for i in 2.. {\n        let fib_num = fib_nums[i - 1] + fib_nums[i - 2];\n        fib_nums.push(fib_num);\n\n        if is_prime(fib_num) {\n            prime_fibs.push(fib_num);\n        }\n\n        if prime_fibs.len() == n as usize {\n            return prime_fibs[n as usize - 1];\n        }\n    }\n\n    -1"], ["/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n    let mut balance = 0;\n    for operation in operations {\n        balance += operation;\n        if balance < 0 {\n            return true;\n        }\n    }\n    false"], ["/// triples_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are three distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n/// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len() {\n            for k in j+1..l.len() {\n                if l[i] + l[j] + l[k] == 0 {\n                    return true;\n                }\n            }\n        }\n    }\n    false"], ["/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n    n * (n - 1) / 2"], ["/// Return vector with elements incremented by 1.\n/// >>> incr_list(vec![1, 2, 3])\n/// vec![2, 3, 4]\n/// >>> incr_list(vec![5, 3, 5, 2, 3, 3, 9, 0, 123])\n/// vec![6, 4, 6, 3, 4, 4, 10, 1, 124]\nfn incr_list(l: Vec<isize>) -> Vec<isize> {\n    l.iter().map(|x| x + 1).collect()"], ["/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    for i in 0..l.len() {\n        for j in i+1..l.len() {\n            if l[i] + l[j] == 0 {\n                return true;\n            }\n        }\n    }\n    false"], ["/// Change numerical base of input number x to base.\n/// return string representation after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n/// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\")\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n    let mut num = x;\n\n    while num > 0 {\n        let digit = num % base;\n        result.insert(0, char::from_digit(digit as u32, 10).unwrap());\n        num /= base;\n    }\n\n    result"], ["/// Given length of a side and high return area for a triangle.\n/// >>> triangle_area(5, 3)\n/// 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n    (a * h) as f64 / 2.0"], ["/// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fib4(0) -> 0\n/// fib4(1) -> 0\n/// fib4(2) -> 2\n/// fib4(3) -> 0\n/// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n/// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n/// >>> fib4(5)\n/// 4\n/// >>> fib4(6)\n/// 8\n/// >>> fib4(7)\n/// 14\nfn fib4(n: isize) -> isize {\n    let mut fibs = vec![0, 0, 2, 0];\n    for i in 4..=n {\n        let new_fib = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4];\n        fibs.push(new_fib);\n    }\n    fibs[n as usize]"], ["/// Return median of elements in the vector l.\n/// >>> median(vec![3, 1, 2, 4, 5])\n/// 3.0\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l: Vec<isize>) -> f64 {\n    let mut sorted = l.clone();\n    sorted.sort();\n    let len = sorted.len();\n    if len % 2 == 0 {\n        (sorted[len / 2 - 1] + sorted[len / 2]) as f64 / 2.0\n    } else {\n        sorted[len / 2] as f64\n    }"], ["/// Checks if given string is a palindrome\n/// >>> is_palindrome(String::from(\"\"))\n/// true\n/// >>> is_palindrome(String::from(\"aba\"))\n/// true\n/// >>> is_palindrome(String::from(\"aaaaa\"))\n/// true\n/// >>> is_palindrome(String::from(\"zbcd\"))\n/// false\nfn is_palindrome(text: String) -> bool {\n    let chars: Vec<char> = text.chars().collect();\n    let len = chars.len();\n    for i in 0..len/2 {\n        if chars[i] != chars[len-i-1] {\n            return false;\n        }\n    }\n    true"], ["/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n    (2isize.pow(n as u32) % p) as isize"], ["/// For a given vector of input numbers, calculate Mean Absolute Deviation\n/// around the mean of this dataset.\n/// Mean Absolute Deviation is the average absolute difference between each\n/// element and a centerpoint (mean in this case):\n/// MAD = average | x - x_mean |\n/// >>> mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0])\n/// 1.0\nfn mean_absolute_deviation(numbers: Vec<f64>) -> f64 {\n    let mean = numbers.iter().sum::<f64>() / numbers.len() as f64;\n    let mut sum_abs_diff = 0.0;\n    for &number in &numbers {\n        sum_abs_diff += (number - mean).abs();\n    }\n    sum_abs_diff / numbers.len() as f64"], ["/// remove_vowels is a function that takes string and returns string without vowels.\n/// >>> remove_vowels(String::from(\"\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"abcdef\"))\n/// String::from(\"bcdf\")\n/// >>> remove_vowels(String::from(\"aaaaa\"))\n/// String::from(\"\")\n/// >>> remove_vowels(String::from(\"aaBAA\"))\n/// String::from(\"B\")\n/// >>> remove_vowels(String::from(\"zbcd\"))\n/// String::from(\"zbcd\")\nfn remove_vowels(text: String) -> String {\n    text.chars()\n        .filter(|c| !['a', 'e', 'i', 'o', 'u'].contains(&c.to_lowercase().next().unwrap()))\n        .collect()"], ["/// Return true if all numbers in the vector l are below threshold t.\n/// >>> below_threshold(vec![1, 2, 4, 10], 100)\n/// true\n/// >>> below_threshold(vec![1, 20, 4, 10], 5)\n/// false\nfn below_threshold(l: Vec<isize>, t: isize) -> bool {\n    for &n in &l {\n        if n >= t {\n            return false;\n        }\n    }\n    true"], ["/// Add two numbers x and y\n/// >>> add(2, 3)\n/// 5\n/// >>> add(5, 7)\n/// 12\nfn add(x: isize, y: isize) -> isize {\n    x + y"], ["/// Check if two words have the same characters.\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n/// true\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabc\"))\n/// true\n/// >>> same_chars(String::from(\"dddddddabc\"), String::from(\"abcd\"))\n/// true\n/// >>> same_chars(String::from(\"eabcd\"), String::from(\"dddddddabc\"))\n/// false\n/// >>> same_chars(String::from(\"abcd\"), String::from(\"dddddddabce\"))\n/// false\n/// >>> same_chars(String::from(\"eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n/// false\nfn same_chars(s0: String, s1: String) -> bool {\n    let mut s0_chars = s0.chars().collect::<Vec<_>>();\n    let mut s1_chars = s1.chars().collect::<Vec<_>>();\n    s0_chars.sort();\n    s1_chars.sort();\n    s0_chars == s1_chars"], ["/// Return n-th Fibonacci number.\n/// >>> fib(10)\n/// 55\n/// >>> fib(1)\n/// 1\n/// >>> fib(8)\n/// 21\nfn fib(n: isize) -> isize {\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }"], ["/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"<\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n            '<' => stack.push('<'),\n            '>' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                stack.pop();\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()"], ["/// Return true is vector elements are monotonically increasing or decreasing.\n/// >>> monotonic(vec![1, 2, 4, 20])\n/// true\n/// >>> monotonic(vec![1, 20, 4, 10])\n/// false\n/// >>> monotonic(vec![4, 1, 0, -10])\n/// true\nfn monotonic(l: Vec<isize>) -> bool {\n    let mut increasing = true;\n    let mut decreasing = true;\n\n    for i in 1..l.len() {\n        if l[i] < l[i - 1] {\n            increasing = false;\n        }\n        if l[i] > l[i - 1] {\n            decreasing = false;\n        }\n    }\n\n    increasing || decreasing"], ["/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in &l1 {\n        if l2.contains(i) && !result.contains(i) {\n            result.push(*i);\n        }\n    }\n    result.sort();\n    result"], ["/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n/// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n/// 2\nfn largest_prime_factor(n: isize) -> isize {\n    let mut factor = 2;\n    let mut largest_factor = 1;\n\n    while factor * factor <= n {\n        if n % factor == 0 {\n            largest_factor = factor;\n            n /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n\n    if n > largest_factor {\n        n\n    } else {\n        largest_factor\n    }"], ["/// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n/// >>> intersperse(vec![], 4)\n/// Vec::<isize>::new()\n/// >>> intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len() {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n    }\n    result"], ["/// sum_to_n is a function that sums numbers from 1 to n.\n/// >>> sum_to_n(30)\n/// 465\n/// >>> sum_to_n(100)\n/// 5050\n/// >>> sum_to_n(5)\n/// 15\n/// >>> sum_to_n(10)\n/// 55\n/// >>> sum_to_n(1)\n/// 1\nfn sum_to_n(n: isize) -> isize {\n    (n * (n + 1)) / 2"], ["/// brackets is a string of \"(\" and \")\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"(\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n/// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\")(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n            '(' => stack.push('('),\n            ')' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                stack.pop();\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()"], ["/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n/// >>> derivative(vec![3, 1, 2, 4, 5])\n/// vec![1, 4, 12, 20]\n/// >>> derivative(vec![1, 2, 3])\n/// vec![2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n    }\n    result"], ["/// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n/// fibfib(0) == 0\n/// fibfib(1) == 0\n/// fibfib(2) == 1\n/// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n/// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n/// >>> fibfib(1)\n/// 0\n/// >>> fibfib(5)\n/// 4\n/// >>> fibfib(8)\n/// 24\nfn fibfib(n: isize) -> isize {\n    let mut fibfib_seq = vec![0, 0, 1];\n    for i in 3..=n {\n        fibfib_seq.push(fibfib_seq[i as usize - 1] + fibfib_seq[i as usize - 2] + fibfib_seq[i as usize - 3]);\n    }\n    fibfib_seq[n as usize]"], ["/// Write a function vowels_count which takes a string representing\n/// a word as input and returns the number of vowels in the string.\n/// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s: String) -> isize {\n    let mut count = 0;\n    for c in s.chars() {\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' | 'y' => count += 1,\n            _ => (),\n        }\n    }\n    count"], ["/// Circular shift the digits of the integer x, shift the digits right by shift\n/// and return the result as a string.\n/// If shift > number of digits, return digits reversed.\n/// >>> circular_shift(12, 1)\n/// String::from(\"21\")\n/// >>> circular_shift(12, 2)\n/// String::from(\"12\")\nfn circular_shift(x: isize, shift: isize) -> String {\n    let mut digits: Vec<char> = x.to_string().chars().collect();\n    let len = digits.len() as isize;\n    if shift > len {\n        digits.reverse();\n    } else {\n        let shift = shift % len;\n        let mut shifted = vec![0; len as usize];\n        for i in 0..len {\n            let j = (i + len - shift) % len;\n            shifted[j as usize] = digits[i as usize];\n        }\n        digits = shifted;\n    }\n    digits.iter().collect()"], ["/// Task\n/// Write a function that takes a string as input and returns the sum of the upper characters only'\n/// ASCII codes.\n/// Examples:\n/// >>> digitSum(String::from(\"\"))\n/// 0\n/// >>> digitSum(String::from(\"abAB\"))\n/// 131\n/// >>> digitSum(String::from(\"abcCd\"))\n/// 67\n/// >>> digitSum(String::from(\"helloE\"))\n/// 69\n/// >>> digitSum(String::from(\"woArBld\"))\n/// 131\n/// >>> digitSum(String::from(\"aAaaaXa\"))\n/// 153\nfn digitSum(s: String) -> isize {\n    s.chars().fold(0, |acc, c| if c.is_uppercase() { acc + c as isize } else { acc })"], ["/// In this task, you will be given a string that represents a number of apples and oranges \n/// that are distributed in a basket of fruit this basket contains \n/// apples, oranges, and mango fruits. Given the string that represents the total number of \n/// the oranges and apples and an integer that represent the total number of the fruits \n/// in the basket return the number of the mango fruits in the basket.\n/// for examble:\n/// >>> fruit_distribution(String::from(\"5 apples and 6 oranges\"), 19)\n/// 8\n/// >>> fruit_distribution(String::from(\"0 apples and 1 oranges\"), 3)\n/// 2\n/// >>> fruit_distribution(String::from(\"2 apples and 3 oranges\"), 100)\n/// 95\n/// >>> fruit_distribution(String::from(\"100 apples and 1 oranges\"), 120)\n/// 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n    let mut count = 0;\n    let mut total = 0;\n    let mut num_str = String::new();\n    let mut num = 0;\n    let mut fruit = String::new();\n    let mut fruits = vec![];\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            num_str.push(c);\n        } else if c == ' ' {\n            num = num_str.parse::<isize>().unwrap();\n            num_str = String::new();\n        } else {\n            fruit.push(c);\n            if fruit.len() > 0 {\n                fruits.push(fruit.clone());\n                fruit = String::new();\n            }\n        }\n    }\n\n    for i in 0..fruits.len() {\n        if fruits[i] == \"apples\" {\n            count += num;\n        } else if fruits[i] == \"oranges\" {\n            count += num;\n        }\n    }\n\n    total = n - count;\n\n    total"], ["/// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n/// your task is to pluck one of the nodes and return it.\n/// The plucked node should be the node with the smallest even value.\n/// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n/// The plucked node should be returned in a vector, [ smalest_value, its index ],\n/// If there are no even values or the given vector is empty, return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n/// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n/// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::MAX;\n    let mut min_index = -1;\n    for (i, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n            min_index = i as isize;\n        }\n    }\n    if min_index == -1 {\n        vec![min_even, min_index]\n    } else {\n        vec![min_even, min_index]\n    }"], ["/// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n/// zero, and has a frequency greater than or equal to the value of the integer itself. \n/// The frequency of an integer is the number of times it appears in the vector.\n/// If no such a value exist, return -1.\n/// Examples:\n/// >>> search(vec![4, 1, 2, 2, 3, 1])\n/// 2\n/// >>> search(vec![1, 2, 2, 3, 3, 3, 4, 4, 4])\n/// 3\n/// >>> search(vec![5, 5, 4, 4, 4])\n/// -1\nfn search(lst: Vec<isize>) -> isize {\n    let mut freq = std::collections::HashMap::new();\n    for &num in lst.iter() {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n    for num in (1..).rev() {\n        if *freq.get(&num).unwrap_or(&0) >= num {\n            return num;\n        }\n    }\n    -1"], ["/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n    let mut max_depths = Vec::new();\n    let mut current_depth = 0;\n    for c in paren_string.chars() {\n        match c {\n            '(' => {\n                current_depth += 1;\n                if current_depth > max_depths.len() as isize {\n                    max_depths.push(current_depth);\n                }\n            }\n            ')' => {\n                current_depth -= 1;\n            }\n            _ => {}\n        }\n    }\n    max_depths"], ["/// Given vector of integers, return vector in strange order.\n/// Strange sorting, is when you start with the minimum value,\n/// then maximum of the remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(vec![1, 2, 3, 4])\n/// vec![1, 4, 2, 3]\n/// >>> strange_sort_list(vec![5, 5, 5, 5])\n/// vec![5, 5, 5, 5]\n/// >>> strange_sort_list(vec![])\n/// Vec::<isize>::new()\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    let mut result = Vec::new();\n    let mut i = 0;\n    let mut j = sorted.len() - 1;\n    while i <= j {\n        result.push(sorted[i]);\n        if i != j {\n            result.push(sorted[j]);\n        }\n        i += 1;\n        j -= 1;\n    }\n    result"], ["/// Given the lengths of the three sides of a triangle. Return the area of\n/// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum of any two sides is greater \n/// than the third side.\n/// Example:\n/// >>> triangle_area(3, 4, 5)\n/// 6.0\n/// >>> triangle_area(1, 2, 10)\n/// -1.0\nfn triangle_area(a: isize, b: isize, c: isize) -> f64 {\n    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        (area * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }"], ["/// Write a function that returns true if the object q will fly, and false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n/// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>> will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n/// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for i in 0..q.len() {\n        sum += q[i];\n    }\n    if sum > w {\n        return false;\n    }\n    for i in 0..q.len()/2 {\n        if q[i] != q[q.len()-1-i] {\n            return false;\n        }\n    }\n    true"], ["/// Given a vector arr of integers, find the minimum number of elements that\n/// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n/// is read the same backwards and forwards. In one change, you can change one element to any other element.\n/// For example:\n/// >>> smallest_change(vec![1, 2, 3, 5, 4, 7, 9, 6])\n/// 4\n/// >>> smallest_change(vec![1, 2, 3, 4, 3, 2, 2])\n/// 1\n/// >>> smallest_change(vec![1, 2, 3, 2, 1])\n/// 0\nfn smallest_change(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n\n    while i < j {\n        if arr[i] != arr[j] {\n            count += 1;\n        }\n        i += 1;\n        j -= 1;\n    }\n\n    count"], ["/// Write a function that accepts two vectors of strings and returns the vector that has \n/// total number of chars in the all strings of the vector less than the other vector.\n/// if the two vectors have the same number of chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n/// Vec::<String>::new()\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n/// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n/// >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n    let lst1_len = lst1.iter().map(|s| s.len()).sum::<usize>();\n    let lst2_len = lst2.iter().map(|s| s.len()).sum::<usize>();\n    if lst1_len < lst2_len {\n        lst1\n    } else {\n        lst2\n    }"], ["/// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n/// and false otherwise.\n/// Knowing that (a) is less then 100. \n/// Example:\n/// >>> is_multiply_prime(30)\n/// true\n/// 30 = 2 * 3 * 5\nfn is_multiply_prime(a: isize) -> bool {\n    let mut num = a;\n    let mut count = 0;\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\n    for prime in primes.iter() {\n        while num % prime == 0 {\n            num /= prime;\n            count += 1;\n        }\n    }\n\n    count == 3 && num == 1"], ["/// Your task is to write a function that returns true if a number x is a simple\n/// power of n and false in other cases.\n/// x is a simple power of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n/// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n/// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n/// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut power = n;\n    while power < x {\n        power *= n;\n    }\n    power == x"], ["/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let cube_root = (a as f64).cbrt().round() as isize;\n    cube_root * cube_root * cube_root == a"], ["/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let mut count = 0;\n    for c in num.chars() {\n        match c {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => count += 1,\n            _ => (),\n        }\n    }\n    count"], ["/// You will be given a number in decimal form and your task is to convert it to\n/// binary format. The function should return a string, with each character representing a binary\n/// number. Each character in the string will be '0' or '1'.\n/// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n/// The extra characters are there to help with the format.\n/// Examples:\n/// >>> decimal_to_binary(15)\n/// String::from(\"db1111db\")\n/// >>> decimal_to_binary(32)\n/// String::from(\"db100000db\")\nfn decimal_to_binary(decimal: isize) -> String {\n    let binary = format!(\"{:b}\", decimal);\n    format!(\"db{}db\", binary)"], ["/// Filter an input vector of strings only for ones that contain given substring\n/// >>> filter_by_substring(vec![], String::from(\"a\"))\n/// Vec::<String>::new()\n/// >>> filter_by_substring(vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"cde\"), String::from(\"array\")], String::from(\"a\"))\n/// vec![String::from(\"abc\"), String::from(\"bacd\"), String::from(\"array\")]\nfn filter_by_substring(strings: Vec<String>, substring: String) -> Vec<String> {\n    strings.into_iter().filter(|s| s.contains(&substring)).collect()"], ["/// You are given a string s.\n/// Your task is to check if the string is haprs or not.\n/// A string is haprs if its length is at least 3 and every 3 consecutive letters are distinct\n/// For example:\n/// >>> is_happy(String::from(\"a\"))\n/// false\n/// >>> is_happy(String::from(\"aa\"))\n/// false\n/// >>> is_happy(String::from(\"abcd\"))\n/// true\n/// >>> is_happy(String::from(\"aabb\"))\n/// false\n/// >>> is_happy(String::from(\"adb\"))\n/// true\n/// >>> is_happy(String::from(\"xyy\"))\n/// false\nfn is_happy(s: String) -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let mut prev = s.chars().nth(0).unwrap();\n    let mut curr = s.chars().nth(1).unwrap();\n    for c in s.chars().skip(2) {\n        if prev != curr && curr != c && prev != c {\n            return true;\n        }\n        prev = curr;\n        curr = c;\n    }\n    false"], ["/// It is the last week of the semester and the teacher has to give the grades\n/// to students. The teacher has been making her own algorithm for grading.\n/// The only problem is, she has lost the code she used for grading.\n/// She has given you a vector of GPAs for some students and you have to write \n/// a function that can output a vector of letter grades using the following table:\n/// GPA       |    Letter grade\n/// 4.0                A+\n/// > 3.7                A \n/// > 3.3                A- \n/// > 3.0                B+\n/// > 2.7                B \n/// > 2.3                B-\n/// > 2.0                C+\n/// > 1.7                C\n/// > 1.3                C-\n/// > 1.0                D+ \n/// > 0.7                D \n/// > 0.0                D-\n/// 0.0                E\n/// Example:\n/// >>> grade_equation(vec![4.0, 3, 1.7, 2, 3.5])\n/// vec![String::from(\"A+\"), String::from(\"B\"), String::from(\"C-\"), String::from(\"C\"), String::from(\"A-\")]\nfn numerical_letter_grade(grades: Vec<f64>) -> Vec<String> {\n    grades.iter().map(|&g| match g {\n        g if g >= 4.0 => \"A+\".to_string(),\n        g if g > 3.7 => \"A\".to_string(),\n        g if g > 3.3 => \"A-\".to_string(),\n        g if g > 3.0 => \"B+\".to_string(),\n        g if g > 2.7 => \"B\".to_string(),\n        g if g > 2.3 => \"B-\".to_string(),\n        g if g > 2.0 => \"C+\".to_string(),\n        g if g > 1.7 => \"C\".to_string(),\n        g if g > 1.3 => \"C-\".to_string(),\n        g if g > 1.0 => \"D+\".to_string(),\n        g if g > 0.7 => \"D\".to_string(),\n        g if g > 0.0 => \"D-\".to_string(),\n        _ => \"E\".to_string(),\n    }).collect()"], ["/// Write a function that takes a string and returns true if the string\n/// length is a prime number or false otherwise\n/// Examples\n/// >>> prime_length(String::from(\"Hello\"))\n/// true\n/// >>> prime_length(String::from(\"abcdcba\"))\n/// true\n/// >>> prime_length(String::from(\"kittens\"))\n/// true\n/// >>> prime_length(String::from(\"orange\"))\n/// false\nfn prime_length(string: String) -> bool {\n    let length = string.len();\n    if length < 2 {\n        return false;\n    }\n    for i in 2..length {\n        if length % i == 0 {\n            return false;\n        }\n    }\n    true"], ["/// Given a positive integer n, return the count of the numbers of n-digit\n/// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) -> isize {\n    if n == 1 {\n        return 1;\n    }\n    let mut count = 0;\n    for i in 0..n {\n        count += (10_isize.pow(i) - 1) * (10_isize.pow(n - i - 1) - 1) + 1;\n    }\n    count"], ["/// Given a positive integer N, return the total sum of its digits in binary.\n/// Example\n/// >>> solve(1000)\n/// String::from(\"1\")\n/// >>> solve(150)\n/// String::from(\"110\")\n/// >>> solve(147)\n/// String::from(\"1100\")\n/// Variables:\n/// @N integer\n/// Constraints: 0 \u2264 N \u2264 10000.\n/// Output:\n/// a string of binary number\nfn solve(N: isize) -> String {\n    let mut sum = 0;\n    let mut n = N;\n    while n > 0 {\n        sum += n % 2;\n        n /= 2;\n    }\n    format!(\"{:b}\", sum)"], ["/// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n/// Examples:\n/// >>> add(vec![4, 2, 6, 7])\n/// 2\nfn add(lst: Vec<isize>) -> isize {\n    lst.iter().enumerate()\n        .filter(|&(i, _)| i % 2 != 0)\n        .filter(|&(_, x)| x % 2 == 0)\n        .map(|(_, x)| x)\n        .sum()"], ["/// Write a function that takes a string and returns an ordered version of it.\n/// Ordered version of string, is a string where all words (separated by space)\n/// are replaced by a new word where all the characters arranged in\n/// ascending order based on ascii value.\n/// Note: You should keep the order of words and blank spaces in the sentence.\n/// For example:\n/// >>> anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String) -> String {\n    s.split_whitespace()\n        .map(|word| {\n            let mut chars: Vec<char> = word.chars().collect();\n            chars.sort_by(|a, b| a.cmp(b));\n            chars.into_iter().collect()\n        })\n        .collect::<Vec<String>>()\n        .join(\" \")"], ["/// You are given a 2 dimensional data, as a nested vectors,\n/// which is similar to matrix, however, unlike matrices,\n/// each row may contain a different number of columns.\n/// Given lst, and integer x, find integers x in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize, isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut result = Vec::new();\n    for (i, row) in lst.iter().enumerate() {\n        for (j, &val) in row.iter().enumerate() {\n            if val == x {\n                result.push((i as isize, j as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    result"], ["/// Given a vector of non-negative integers, return a cors of the given vector after sorting,\n/// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n/// or sort it in descending order if the sum( first index value, last index value) is even.\n/// Note:\n/// * don't change the given vector.\n/// Examples:\n/// >>> sort_array(vec![])\n/// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3, 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted = array.clone();\n    sorted.sort();\n    if (sorted[0] + sorted[sorted.len() - 1]) % 2 == 0 {\n        sorted.reverse();\n    }\n    sorted"], ["/// Create a function encrypt that takes a string as an argument and\n/// returns a string encrypted with the alphabet being rotated. \n/// The alphabet should be rotated in a manner such that the letters \n/// shift down by two multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n/// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s: String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars() {\n        let mut new_c = c as u8 + 2 * 2;\n        if new_c > 'z' as u8 {\n            new_c -= 26;\n        }\n        encrypted.push(new_c as char);\n    }\n    encrypted"], ["/// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n/// Empty sum should be equal to 0 and empty product should be equal to 1.\n/// >>> sum_product(vec![])\n/// (0, 1)\n/// >>> sum_product(vec![1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>) -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n\n    for number in numbers {\n        sum += number;\n        product *= number;\n    }\n\n    (sum, product)"], ["/// You are given a vector of integers.\n/// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n/// Return None if there is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n/// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n/// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n    if lst.len() < 2 {\n        return None;\n    }\n    let mut smallest = lst[0];\n    let mut second_smallest = lst[1];\n    if second_smallest < smallest {\n        std::mem::swap(&mut smallest, &mut second_smallest);\n    }\n    for &num in &lst[2..] {\n        if num < smallest {\n            second_smallest = smallest;\n            smallest = num;\n        } else if num < second_smallest && num != smallest {\n            second_smallest = num;\n        }\n    }\n    if smallest == second_smallest {\n        None\n    } else {\n        Some(second_smallest)\n    }"], ["/// You'll be given a string of words, and your task is to count the number\n/// of boredoms. A boredom is a sentence that starts with the word \"I\".\n/// Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize {\n    let mut count = 0;\n    let mut sentence = String::new();\n\n    for c in S.chars() {\n        sentence.push(c);\n\n        if c == '.' || c == '?' || c == '!' {\n            if sentence.starts_with(\"I \") {\n                count += 1;\n            }\n\n            sentence = String::new();\n        }\n    }\n\n    count"], ["/// Create a function that takes 3 numbers.\n/// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n/// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n/// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n/// true\n/// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z: f64) -> bool {\n    if x.is_integer() && y.is_integer() && z.is_integer() {\n        return x == y + z || y == x + z || z == x + y;\n    }\n    false"], ["/// Write a function that takes a message, and encodes in such a \n/// way that it swaps case of all letters, replaces all vowels in \n/// the message with the letter that appears 2 places ahead of that \n/// vowel in the english alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String) -> String {\n    let mut encoded = String::new();\n    for c in message.chars() {\n        let mut new_c = c;\n        if c.is_alphabetic() {\n            new_c = match c.to_ascii_lowercase() {\n                'a' => 'c',\n                'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n                'u' => 's',\n                'y' => 'a',\n                _ => c,\n            };\n            if c.is_uppercase() {\n                new_c = new_c.to_uppercase();\n            }\n        }\n        encoded.push(new_c);\n    }\n    encoded"], ["/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n    let mut largest_prime = 0;\n    for num in lst {\n        if is_prime(num) && num > largest_prime {\n            largest_prime = num;\n        }\n    }\n    sum_of_digits(largest_prime)"], ["use std::collections::HashMap;\n\n/// Given a HashMap, return true if all keys are strings in lower \n/// case or all keys are strings in upper case, else return false.\n/// The function should return false is the given HashMap is empty.\n/// Examples:\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"b\"), String::from(\"banana\"))]))\n/// true\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"banana\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"a\"), String::from(\"apple\")), (8, String::from(\"banana\")), (String::from(\"a\"), String::from(\"apple\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")), (String::from(\"City\"), String::from(\"Houston\"))]))\n/// false\n/// >>> check_dict_case(HashMap::from([(String::from(\"STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"))]))\n/// true\nfn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty() {\n        return false;\n    }\n\n    let mut all_lower = true;\n    let mut all_upper = true;\n\n    for key in dict.keys() {\n        if !key.is_ascii() {\n            return false;\n        }\n\n        if key.to_lowercase() != key {\n            all_lower = false;\n        }\n\n        if key.to_uppercase() != key {\n            all_upper = false;\n        }\n    }\n\n    all_lower || all_upper"], ["/// Implement a function that takes an non-negative integer and returns a vector of the first n\n/// integers that are prime numbers and less than n.\n/// for example:\n/// >>> count_up_to(5)\n/// vec![2, 3]\n/// >>> count_up_to(11)\n/// vec![2, 3, 5, 7]\n/// >>> count_up_to(0)\n/// Vec::<isize>::new()\n/// >>> count_up_to(20)\n/// vec![2, 3, 5, 7, 11, 13, 17, 19]\n/// >>> count_up_to(1)\n/// Vec::<isize>::new()\n/// >>> count_up_to(18)\n/// vec![2, 3, 5, 7, 11, 13, 17]\nfn count_up_to(n: isize) -> Vec<isize> {\n    let mut primes = Vec::new();\n    for i in 2..n {\n        let mut is_prime = true;\n        for j in 2..i {\n            if i % j == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n        if is_prime {\n            primes.push(i);\n        }\n    }\n    primes"], ["/// Complete the function that takes two integers and returns \n/// the product of their unit digits.\n/// Assume the input is always valid.\n/// Examples:\n/// >>> multiply(148, 412)\n/// 16\n/// >>> multiply(19, 28)\n/// 72\n/// >>> multiply(2020, 1851)\n/// 0\n/// >>> multiply(14, -15)\n/// 20\nfn multiply(a: isize, b: isize) -> isize {\n    (a % 10) * (b % 10)"], ["/// Given a string s, count the number of uppercase vowels in even indices.\n/// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>> count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    let mut count = 0;\n    for (i, c) in s.chars().enumerate() {\n        if i % 2 == 0 && c.is_uppercase() && \"AEIOU\".contains(c) {\n            count += 1;\n        }\n    }\n    count"], ["/// Create a function that takes a value (string) representing a number\n/// and returns the closest integer to it. If the number is equidistant\n/// from two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n/// Rounding away from zero means that if the given number is equidistant\n/// from two integers, the one you should return is the one that is the\n/// farthest from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"-14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n    let num: f64 = value.parse().unwrap();\n    num.round() as isize"], ["/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    let mut max_numbers = Vec::new();\n    let mut current_max = isize::MIN;\n\n    for number in numbers {\n        if number > current_max {\n            current_max = number;\n        }\n        max_numbers.push(current_max);\n    }\n\n    max_numbers"]]