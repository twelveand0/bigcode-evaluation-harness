[["--  Check if in given table of numbers, are any two numbers closer to each other than\n-- given threshold.\n-- >>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\n-- false\n-- >>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n-- true\nlocal function has_close_elements(numbers, threshold)\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      if math.abs(numbers[i] - numbers[j]) <= threshold then\n        return true\n      end\n    end\n  end\n  return false\nend"], ["-- Given a positive integer n, you have to make a pile of n levels of stones.\n-- The first level has n stones.\n-- The number of stones in the next level is:\n--     - the next odd number if n is odd.\n--     - the next even number if n is even.\n-- Return the number of stones in each level in a table, where element at index\n-- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n-- {3, 5, 7}\nlocal function make_a_pile(n)\n    local stones = {}\n    local next_num = n % 2 == 0 and n + 1 or n + 2\n    for i = 1, n do\n        table.insert(stones, next_num)\n        next_num = next_num + 2\n    end\n    return stones\nend\n"], ["-- You will be given a string of words separated by commas or spaces. Your task is\n-- to split the string into words and return a table of the words.\n-- For example:\n-- >>> words_string('Hi, my name is John')\n-- {'Hi', 'my', 'name', 'is', 'John'}\n-- >>> words_string('One, two, three, four, five, six')\n-- {'One', 'two', 'three', 'four', 'five', 'six'}\nlocal function words_string(s)\n  local words = {}\n  for word in s:gmatch(\"%S+\") do\n    table.insert(words, word)\n  end\n  return words\nend\n"], ["-- This function takes two positive numbers x and y and returns the\n-- biggest even integer number that is in the range [x, y] inclusive. If \n-- there's no such number, then the function should return -1.\n-- For example:\n-- >>> choose_num(12, 15)\n-- 14\n-- >>> choose_num(13, 12)\n-- -1\nlocal function choose_num(x, y)\n  local num = y\n  while num >= x do\n    if num % 2 == 0 then\n      return num\n    end\n    num = num - 1\n  end\n  return -1\nend"], ["-- You are given two positive integers n and m, and your task is to compute the\n-- average of the integers from n through m (including n and m). \n-- Round the answer to the nearest integer and convert that to binary.\n-- If n is greater than m, return -1.\n-- Example:\n-- >>> rounded_avg(1, 5)\n-- '0b11'\n-- >>> rounded_avg(7, 5)\n-- -1\n-- >>> rounded_avg(10, 20)\n-- '0b1111'\n-- >>> rounded_avg(20, 33)\n-- '0b11010'\nlocal function rounded_avg(n, m)\n  if n > m then\n    return -1\n  end\n  local sum = 0\n  for i = n, m do\n    sum = sum + i\n  end\n  local avg = math.floor((sum / (m - n + 1)) + 0.5)\n  return string.format(\"0b%b\", avg)\nend\n"], ["-- Given a table of positive integers x. return a sorted table of all \n-- elements that hasn't any even digit.\n-- Note: Returned table should be sorted in increasing order.\n-- For example:\n-- >>> unique_digits({15, 33, 1422, 1})\n-- {1, 15, 33}\n-- >>> unique_digits({152, 323, 1422, 10})\n-- {}\nlocal function unique_digits(x)\n    local result = {}\n    for _, num in ipairs(x) do\n        local has_even_digit = false\n        for digit in string.gmatch(tostring(num), \"%d\") do\n            if tonumber(digit) % 2 == 0 then\n                has_even_digit = true\n                break\n            end\n        end\n        if not has_even_digit then\n            table.insert(result, num)\n        end\n    end\n    table.sort(result)\n    return result\nend"], ["-- Given a table of integers, sort the integers that are between 1 and 9 inclusive,\n-- reverse the resulting table, and then replace each digit by its corresponding name from\n-- \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n-- For example:\n-- >>> by_length({2, 1, 1, 4, 5, 8, 2, 3})\n-- {'Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One'}\n--   If the table is empty, return an empty table:\n-- >>> by_length({})\n-- {}\n--   If the table has any strange number ignore it:\n-- >>> by_length({1, -1, 55})\n-- {'One'}\nlocal function by_length(arr)\n    local names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n    local filtered = {}\n    for i, v in ipairs(arr) do\n        if v >= 1 and v <= 9 then\n            table.insert(filtered, v)\n        end\n    end\n    table.sort(filtered)\n    local reversed = {}\n    for i = #filtered, 1, -1 do\n        table.insert(reversed, names[filtered[i]])\n    end\n    return reversed\nend\n"], ["--  Implement the function f that takes n as a parameter,\n-- and returns a table of size n, such that the value of the element at index i is the factorial of i if i is even\n-- or the sum of numbers from 1 to i otherwise.\n-- i starts from 1.\n-- the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n-- Example:\n-- >>> f(5)\n-- {1, 2, 6, 24, 15}\nlocal function f(n)\n  local t = {}\n  for i = 1, n do\n    if i % 2 == 0 then\n      local fact = 1\n      for j = 1, i do\n        fact = fact * j\n      end\n      t[i] = fact\n    else\n      local sum = 0\n      for j = 1, i do\n        sum = sum + j\n      end\n      t[i] = sum\n    end\n  end\n  return t\nend"], ["-- Given a positive integer n, return a table that has the number of even and odd\n-- integer palindromes that fall within the range(1, n), inclusive.\n-- Example 1:\n-- >>> even_odd_palindrome(3)\n-- {1, 2}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n-- Example 2:\n-- >>> even_odd_palindrome(12)\n-- {4, 6}\n--     Explanation:\n--     Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n-- Note:\n--     1. 1 <= n <= 10^3\n--     2. returned table has the number of even and odd integer palindromes respectively.\nlocal function even_odd_palindrome(n)\n    local even_count = 0\n    local odd_count = 0\n    for i = 1, n do\n        local str = tostring(i)\n        if str == string.reverse(str) then\n            if i % 2 == 0 then\n                even_count = even_count + 1\n            else\n                odd_count = odd_count + 1\n            end\n        end\n    end\n    return {even_count, odd_count}\nend\n"], ["-- Write a function count_nums which takes a table of integers and returns\n-- the number of elements which has a sum of digits > 0.\n-- If a number is negative, then its first signed digit will be negative:\n-- e.g. -123 has signed digits -1, 2, and 3.\n-- >>> count_nums({})\n-- 0\n-- >>> count_nums({-1, 11, -11})\n-- 1\n-- >>> count_nums({1, 1, 2})\n-- 3\nlocal function count_nums(arr)\n    local count = 0\n    for _, num in ipairs(arr) do\n        local sum = 0\n        local num_str = tostring(num)\n        for _, digit in ipairs(num_str:gmatch(\".\")) do\n            sum = sum + tonumber(digit)\n        end\n        if sum > 0 then\n            count = count + 1\n        end\n    end\n    return count\nend"], ["-- We have a table 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n-- numbers in the table will be randomly ordered. Your task is to determine if\n-- it is possible to get a table sorted in non-decreasing order by performing \n-- the following operation on the given table:\n--     You are allowed to perform right shift operation any number of times.\n-- One right shift operation means shifting all elements of the table by one\n-- position in the right direction. The last element of the table will be moved to\n-- the starting position in the table i.e. 0th index. \n-- If it is possible to obtain the sorted table by performing the above operation\n-- then return true else return false.\n-- If the given table is empty then return true.\n-- Note: The given table is guaranteed to have unique elements.\n-- For Example:\n-- >>> move_one_ball({3, 4, 5, 1, 2})\n-- true\n-- Explanation: By performin 2 right shift operations, non-decreasing order can\n--              be achieved for the given table.\n-- >>> move_one_ball({3, 5, 4, 1, 2})\n-- false\n-- Explanation:It is not possible to get non-decreasing order for the given\n--             table by performing any number of right shift operations.\nlocal function move_one_ball(arr)\n    local n = #arr\n    if n == 0 then\n        return true\n    end\n    local sorted = true\n    for i = 1, n do\n        if arr[i] > arr[(i % n) + 1] then\n            sorted = false\n            break\n        end\n    end\n    return sorted\nend\n"], ["--  Find the shortest palindrome that begins with a supplied string.\n-- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n-- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n  local reversed = string:reverse()\n  local length = string.len(string)\n  for i = 1, length do\n    if string:sub(i) == reversed:sub(1, length - i + 1) then\n      return string .. reversed:sub(length - i + 2)\n    end\n  end\n  return string .. reversed\nend"], ["-- In this problem, you will implement a function that takes two tables of numbers,\n-- and determines whether it is possible to perform an exchange of elements\n-- between them to make lst1 a table of only even numbers.\n-- There is no limit on the number of exchanged elements between lst1 and lst2.\n-- If it is possible to exchange elements between the lst1 and lst2 to make\n-- all the elements of lst1 to be even, return \"YES\".\n-- Otherwise, return \"NO\".\n-- For example:\n-- >>> exchange({1, 2, 3, 4}, {1, 2, 3, 4})\n-- 'YES'\n-- >>> exchange({1, 2, 3, 4}, {1, 5, 3, 4})\n-- 'NO'\n-- It is assumed that the input tables will be non-empty.\nlocal function exchange(lst1, lst2)\n  local even_count = 0\n  local odd_count = 0\n  for _, num in ipairs(lst1) do\n    if num % 2 == 0 then\n      even_count = even_count + 1\n    else\n      odd_count = odd_count + 1\n    end\n  end\n  for _, num in ipairs(lst2) do\n    if num % 2 == 0 then\n      even_count = even_count + 1\n    else\n      odd_count = odd_count + 1\n    end\n  end\n  if odd_count > even_count then\n    return \"NO\"\n  else\n    return \"YES\"\n  end\nend\n"], ["-- Given a string representing a space separated lowercase letters, return a table\n-- of the letter with the most repetition and containing the corresponding count.\n-- If several letters have the same occurrence, return all of them.\n-- Example:\n-- >>> histogram('a b c')\n-- {['a'] = 1, ['b'] = 1, ['c'] = 1}\n-- >>> histogram('a b b a')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('a b c a b')\n-- {['a'] = 2, ['b'] = 2}\n-- >>> histogram('b b b b a')\n-- {['b'] = 4}\n-- >>> histogram('')\n-- {}\nlocal function histogram(test)\n    local letters = {}\n    local max_count = 0\n    local result = {}"], ["-- Task\n-- We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n-- then check if the result string is palindrome.\n-- A string is called palindrome if it reads the same backward as forward.\n-- You should return a table containing the result string and true/false for the check.\n-- Example\n-- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n-- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba', 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n    local result = ''\n    for i = 1, #s do\n        local char = s:sub(i, i)\n        if not c:find(char) then\n            result = result .. char\n        end\n    end\n    local is_palindrome = result == result:reverse()\n    return {result, is_palindrome}\nend\n"], ["-- Given a table of strings, where each string consists of only digits, return a table.\n-- Each element i of the output should be \"the number of odd elements in the\n-- string i of the input.\" where all the i's should be replaced by the number\n-- of odd digits in the i'th string of the input.\n-- >>> odd_count({'1234567'})\n-- {'the number of odd elements 4n the str4ng 4 of the 4nput.'}\n-- >>> odd_count({'3', '11111111'})\n-- {'the number of odd elements 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8n the str8ng 8 of the 8nput.'}\nlocal function odd_count(lst)\n    local result = {}\n    for i, str in ipairs(lst) do\n        local count = 0\n        for j = 1, #str do\n            if tonumber(str:sub(j, j)) % 2 == 1 then\n                count = count + 1\n            end\n        end\n        table.insert(result, 'the number of odd elements ' .. count .. 'n the str' .. count .. 'ng ' .. count .. ' of the ' .. count .. 'nput.')\n    end\n    return result\nend"], ["-- Given a table of integers nums, find the minimum sum of any non-empty sub-table\n-- of nums.\n-- Example\n-- >>> minSubArraySum({2, 3, 4, 1, 2, 4})\n-- 1\n-- >>> minSubArraySum({-1, -2, -3})\n-- -6\nlocal function minSubArraySum(nums)\n    local minSum = nums[1]\n    local currSum = 0\n    for i = 1, #nums do\n        currSum = math.min(currSum + nums[i], nums[i])\n        minSum = math.min(minSum, currSum)\n    end\n    return minSum\nend"], ["-- You are given a rectangular grid of wells. Each row represents a single well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has a corresponding bucket that can be used to extract water from it, \n-- and all buckets have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example 1:\n-- >>> max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n-- 6\n-- Example 2:\n-- >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)\n-- 5\n-- Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}}, 5)\n-- 0\n-- Constraints:\n--     * all wells have the same length\n--     * 1 <= grid.length <= 10^2\n--     * 1 <= grid[:,1].length <= 10^2\n--     * grid[i][j] -> 0 | 1\n--     * 1 <= capacity <= 10\nlocal function max_fill(grid, capacity)\n    local num_rows = #grid\n    local num_cols = #grid[1]\n    local num_buckets = 0\n    local num_wells = 0\n    local num_empty_wells = 0\n    local num_full_buckets = 0\n    local num_empty_buckets = 0\n    local num_wells_per_bucket = capacity\n    local num_buckets_needed = 0"], ["-- In this Kata, you have to sort a table of non-negative integers according to\n-- number of ones in their binary representation in ascending order.\n-- For similar number of ones, sort based on decimal value.\n-- It must be implemented like this:\n-- >>> sort_array({1, 5, 2, 3, 4})\n-- {1, 2, 3, 4, 5}\n-- >>> sort_array({-2, -3, -4, -5, -6})\n-- {-6, -5, -4, -3, -2}\n-- >>> sort_array({1, 0, 2, 3, 4})\n-- {0, 1, 2, 3, 4}\nlocal function sort_array(arr)\n  table.sort(arr, function(a, b)\n    local a_ones = string.gsub(string.format(\"%b\", a), \"0\", \"\")\n    local b_ones = string.gsub(string.format(\"%b\", b), \"0\", \"\")\n    if #a_ones == #b_ones then\n      return a < b\n    else\n      return #a_ones < #b_ones\n    end\n  end)\n  return arr\nend\n"], ["-- Given a string s and a natural number n, you have been tasked to implement \n-- a function that returns a table of all words from string s that contain exactly \n-- n consonants, in order these words appear in the string s.\n-- If the string s is empty then the function should return an empty table.\n-- Note: you may assume the input string contains only letters and spaces.\n-- Examples:\n-- >>> select_words('Mary had a little lamb', 4)\n-- {'little'}\n-- >>> select_words('Mary had a little lamb', 3)\n-- {'Mary', 'lamb'}\n-- >>> select_words('simple white space', 2)\n-- {}\n-- >>> select_words('Hello world', 4)\n-- {'world'}\n-- >>> select_words('Uncle sam', 3)\n-- {'Uncle'}\nlocal function select_words(s, n)\n  local words = {}\n  local consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n  for word in s:gmatch('%S+') do\n    local count = 0\n    for i = 1, #word do\n      if consonants:find(word:sub(i, i)) then\n        count = count + 1\n      end\n    end\n    if count == n then\n      table.insert(words, word)\n    end\n  end\n  return words\nend\n"], ["-- You are given a word. Your task is to find the closest vowel that stands between \n-- two consonants from the right side of the word (case sensitive).\n-- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n-- find any vowel met the above condition. \n-- You may assume that the given string contains English letter only.\n-- Example:\n-- >>> get_closest_vowel('yogurt')\n-- 'u'\n-- >>> get_closest_vowel('FULL')\n-- 'U'\n-- >>> get_closest_vowel('quick')\n-- ''\n-- >>> get_closest_vowel('ab')\n-- ''\nlocal function get_closest_vowel(word)\n  local vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n  local consonants = {'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', 'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'}\n  local closest_vowel = ''\n  local distance = #word\n  for i = #word, 3, -1 do\n    local char = word:sub(i, i)\n    if table.contains(consonants, word:sub(i-1, i-1)) and table.contains(consonants, word:sub(i-2, i-2)) then\n      for j = i-1, 1, -1 do\n        local char2 = word:sub(j, j)\n        if table.contains(vowels, char2) then\n          local new_distance = i - j\n          if new_distance < distance then\n            distance = new_distance\n            closest_vowel = char2\n          end\n          break\n        end\n      end\n    end\n  end\n  return closest_vowel\nend\n"], ["-- You are given a table of two strings, both strings consist of open\n-- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it is possible to concatenate the two strings in\n-- some order, that the resulting string will be good.\n-- A string S is considered to be good if and only if all parentheses in S\n-- are balanced. For example: the string '(())()' is good, while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(', ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n    local s = lst[1] .. lst[2]\n    local stack = {}\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if c == '(' then\n            table.insert(stack, c)\n        else\n            if #stack == 0 then\n                return 'No'\n            end\n            table.remove(stack)\n        end\n    end\n    if #stack == 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\n"], ["--  Input are two strings a and b consisting only of 1s and 0s.\n-- Perform binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010', '110')\n-- '100'\nlocal function string_xor(a, b)\n    local result = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result = result .. '0'\n        else\n            result = result .. '1'\n        end\n    end\n    return result\nend"], ["-- Given a table arr of integers and a positive integer k, return a sorted table \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>> maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4, 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n-- {2}\n-- Note:\n--     1. The length of the table will be in the range of [1, 1000].\n--     2. The elements in the table will be in the range of [-1000, 1000].\n--     3. 0 <= k <= len(arr)\nlocal function maximum(arr, k)\n    table.sort(arr, function(a, b) return a > b end)\n    return table.sub(arr, 1, k)\nend\n"], ["-- Given a non-empty table of integers, return the sum of all of the odd elements that are in even positions.\n-- Examples\n-- >>> solution({5, 8, 7, 1})\n-- 12\n-- >>> solution({3, 3, 3, 3, 3})\n-- 9\n-- >>> solution({30, 13, 24, 321})\n-- 0\nlocal function solution(lst)\n    local sum = 0\n    for i = 1, #lst, 2 do\n        if lst[i] % 2 == 1 then\n            sum = sum + lst[i]\n        end\n    end\n    return sum\nend\n"], ["-- Given a non-empty table of integers arr and an integer k, return\n-- the sum of the elements with at most two digits from the first k elements of arr.\n-- Example:\n-- >>> add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4)\n-- 24\n-- Constraints:\n--     1. 1 <= len(arr) <= 100\n--     2. 1 <= k <= len(arr)\nlocal function add_elements(arr, k)\n    local sum = 0\n    for i = 1, k do\n        local num = arr[i]\n        if num < 100 then\n            sum = sum + num\n        end\n    end\n    return sum\nend\n"], ["-- Given a positive integer n, return a sorted table that has the odd numbers in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n-- as follows: start with any positive integer n. Then each term is obtained from the \n-- previous term as follows: if the previous term is even, the next term is one half of \n-- the previous term. If the previous term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n-- Note: \n--     1. Collatz(1) is [1].\n--     2. returned table sorted in increasing order.\n-- For example:\n-- get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n-- >>> get_odd_collatz(5)\n-- {1, 5}\nlocal function get_odd_collatz(n)\n    local collatz = {}\n    while n ~= 1 do\n        if n % 2 == 0 then\n            n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        if n % 2 == 1 then\n            table.insert(collatz, n)\n        end\n    end\n    table.sort(collatz)\n    return collatz\nend"], ["-- You have to write a function which validates a given date string and\n-- returns true if the date is valid otherwise false.\n-- The date is valid if all of the following rules are satisfied:\n-- 1. The date string is not empty.\n-- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n-- 3. The months should not be less than 1 or higher than 12.\n-- 4. The date should be in the format: mm-dd-yyyy\n-- >>> valid_date('03-11-2000')\n-- true\n-- >>> valid_date('15-01-2012')\n-- false\n-- >>> valid_date('04-0-2040')\n-- false\n-- >>> valid_date('06-04-2020')\n-- true\n-- >>> valid_date('06/04/2020')\n-- false\nlocal function valid_date(date)\n  -- Check if the date string is not empty\n  if date == '' then\n    return false\n  end"], ["-- Given a string of words, return a table of words split on whitespace, if no whitespaces exists in the text you\n-- should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- >>> split_words('Hello world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('Hello,world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('abcdef')\n-- 3\nlocal function split_words(txt)\n  local words = {}\n  local i = 1\n  local j = 1\n  while j <= #txt do\n    if txt:sub(j, j) == ' ' then\n      table.insert(words, txt:sub(i, j-1))\n      i = j+1\n    elseif txt:sub(j, j) == ',' then\n      table.insert(words, txt:sub(i, j-1))\n      i = j+1\n    end\n    j = j+1\n  end\n  table.insert(words, txt:sub(i))\n  if #words == 1 then\n    local count = 0\n    for k = 1, #txt do\n      local c = txt:sub(k, k)\n      if c >= 'a' and c <= 'z' and (c:byte() - 97) % 2 == 0 then\n        count = count + 1\n      end\n    end\n    return count\n  else\n    return words\n  end\nend\n"], ["-- Given a table of numbers, return whether or not they are sorted\n-- in ascending order. If table has more than 1 duplicate of the same\n-- number, return false. Assume no negative numbers and only integers.\n-- Examples\n-- >>> is_sorted({5})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5})\n-- false\n-- >>> is_sorted({1, 2, 3, 4, 5, 6})\n-- true\n-- >>> is_sorted({1, 2, 3, 4, 5, 6, 7})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5, 6, 7})\n-- false\n-- >>> is_sorted({1, 2, 2, 3, 3, 4})\n-- true\n-- >>> is_sorted({1, 2, 2, 2, 3, 4})\n-- false\nlocal function is_sorted(lst)\n    local prev = lst[1]\n    for i = 2, #lst do\n        if lst[i] < prev then\n            return false\n        elseif lst[i] == prev then\n            return false\n        end\n        prev = lst[i]\n    end\n    return true\nend\n"], ["-- You are given two intervals,\n-- where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed which means that the interval (start, end)\n-- includes both start and end.\n-- For each given interval, it is assumed that its start is less or equal its end.\n-- Your task is to determine whether the length of intersection of these two \n-- intervals is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n-- >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1, 1}, {0, 4})\n-- 'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal function intersection(interval1, interval2)\n  local start1, end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  local intersection_start = math.max(start1, start2)\n  local intersection_end = math.min(end1, end2)\n  local intersection_length = intersection_end - intersection_start + 1\n  if intersection_length <= 0 then\n    return \"NO\"\n  end\n  if intersection_length == 1 then\n    return \"NO\"\n  end\n  for i = 2, math.floor(math.sqrt(intersection_length)) do\n    if intersection_length % i == 0 then\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend\n"], ["-- You are given a table arr of integers and you need to return\n-- sum of magnitudes of integers multiplied by product of all signs\n-- of each number in the table, represented by 1, -1 or 0.\n-- Note: return nil for empty arr.\n-- Example:\n-- >>> prod_signs({1, 2, 2, -4})\n-- 9\n-- >>> prod_signs({0, 1})\n-- 0\n-- >>> prod_signs({})\n-- None\nlocal function prod_signs(arr)\n    if #arr == 0 then\n        return nil\n    end\n    local sum = 0\n    local product = 1\n    for i = 1, #arr do\n        sum = sum + math.abs(arr[i])\n        if arr[i] < 0 then\n            product = product * -1\n        elseif arr[i] == 0 then\n            product = 0\n        end\n    end\n    return sum * product\nend\n"], ["-- Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n-- each cell of the grid contains a value. Every integer in the range [1, N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to find the minimum path of length k in the grid. You can start\n-- from any cell, and in each step you can move to any of the neighbor cells,\n-- in other words, you can go to cells which share an edge with you current\n-- cell.\n-- Please note that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a path B (of length k) if\n-- after making the ordered tables of the values on the cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered table of the values on the cells that the minimum path go through.\n-- Examples:    \n-- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>> minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n-- {1}\nlocal function minPath(grid, k)\n    local n = #grid\n    local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n        for j = 1, n do\n            dp[i][j] = {}\n            for l = 1, k do\n                dp[i][j][l] = {}\n            end\n        end\n    end\n    for i = 1, n do\n        for j = 1, n do\n            dp[i][j][1][1] = grid[i][j]\n        end\n    end\n    for l = 2, k do\n        for i = 1, n do\n            for j = 1, n do\n                for x = i - 1, i + 1 do\n                    for y = j - 1, j + 1 do\n                        if x >= 1 and x <= n and y >= 1 and y <= n then\n                            for p = 1, l - 1 do\n                                for q = 1, #dp[x][y][p] do\n                                    local path = {}\n                                    for r = 1, #dp[i][j][p] do\n                                        path[r] = dp[i][j][p][r]\n                                    end\n                                    for r = 1, #dp[x][y][p] do\n                                        path[#path + 1] = dp[x][y][p][r]\n                                    end\n                                    if #path == l then\n                                        local found = false\n                                        for r = 1, #dp[i][j][l] do\n                                            if #dp[i][j][l][r] == l and dp[i][j][l][r][1] < path[1] then\n                                                found = true\n                                                break\n                                            end\n                                        end\n                                        if not found then\n                                            dp[i][j][l][#dp[i][j][l] + 1] = path\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n    local minPath = {}\n    for i = 1, n do\n        for j = 1, n do\n            for l = 1, k do\n                for p = 1, #dp[i][j][l] do\n                    local path = dp[i][j][l][p]\n                    if #path == k then\n                        if #minPath == 0 then\n                            minPath = path\n                        else\n                            local found = false\n                            for q = 1, #minPath do\n                                if minPath[q] < path[q] then\n                                    found = true\n                                    break\n                                elseif minPath[q] > path[q] then\n                                    break\n                                end\n                            end\n                            if not found then\n                                minPath = path\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n    return minPath\nend\n"], ["--  Out of table of strings, return the longest one. Return the first one in case of multiple\n-- strings of the same length. Return nil in case the input table is empty.\n-- >>> longest({})\n-- None\n-- >>> longest({'a', 'b', 'c'})\n-- 'a'\n-- >>> longest({'a', 'bb', 'ccc'})\n-- 'ccc'\nlocal function longest(strings)\n  local longest_string = nil\n  local longest_length = 0\n  for _, string in ipairs(strings) do\n    local length = string.len(string)\n    if length > longest_length then\n      longest_string = string\n      longest_length = length\n    end\n  end\n  return longest_string\nend"], ["-- Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n-- the last couple centuries. However, what people don't know is Tribonacci sequence.\n-- Tribonacci sequence is defined by the recurrence:\n-- tri(1) = 3\n-- tri(n) = 1 + n / 2, if n is even.\n-- tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n-- For example:\n-- tri(2) = 1 + (2 / 2) = 2\n-- tri(4) = 3\n-- tri(3) = tri(2) + tri(1) + tri(4)\n--        = 2 + 3 + 3 = 8 \n-- You are given a non-negative integer number n, you have to a return a table of the \n-- first n + 1 numbers of the Tribonacci sequence.\n-- Examples:\n-- >>> tri(3)\n-- {1, 3, 2, 8}\nlocal function tri(n)\n  local result = {}\n  for i = 1, n + 1 do\n    if i == 1 then\n      result[i] = 3\n    elseif i % 2 == 0 then\n      result[i] = 1 + i / 2\n    else\n      result[i] = result[i - 1] + result[i - 2] + result[i + 1]\n    end\n  end\n  return result\nend"], ["-- Given a positive integer n, return the product of the odd digits.\n-- Return 0 if all digits are even.\n-- For example:\n-- >>> digits(1)\n-- 1\n-- >>> digits(4)\n-- 0\n-- >>> digits(235)\n-- 15\nlocal function digits(n)\n  local product = 1\n  while n > 0 do\n    local digit = n % 10\n    if digit % 2 == 1 then\n      product = product * digit\n    end\n    n = (n - digit) / 10\n  end\n  if product == 1 then\n    return 0\n  else\n    return product\n  end\nend\n"], ["-- Create a function that takes a string as input which contains only square brackets.\n-- The function should return true if and only if there is a valid subsequence of brackets \n-- where at least one bracket in the subsequence is nested.\n-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n-- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n-- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal function is_nested(string)\n  local stack = {}\n  for i = 1, #string do\n    local c = string:sub(i, i)\n    if c == \"[\" then\n      table.insert(stack, c)\n    elseif c == \"]\" then\n      if #stack > 0 then\n        table.remove(stack)\n      else\n        return false\n      end\n    end\n  end\n  return #stack > 0\nend"], ["-- You are given a table of numbers.\n-- You need to return the sum of squared numbers in the given table,\n-- round each element in the table to the upper int(Ceiling) first.\n-- Examples:\n-- >>> lst({1.0, 2.0, 3.0})\n-- 14\n-- >>> lst({1.0, 4.0, 9.0})\n-- 98\n-- >>> lst({1.0, 3.0, 5.0, 7.0})\n-- 84\n-- >>> lst({1.4, 4.2, 0.0})\n-- 29\n-- >>> lst({-2.4, 1.0, 1.0})\n-- 6\nlocal function sum_squares(lst)\n    local sum = 0\n    for _, num in ipairs(lst) do\n        local ceil_num = math.ceil(num)\n        sum = sum + ceil_num * ceil_num\n    end\n    return sum\nend"], ["-- Create a function that returns true if the last character\n-- of a given string is an alphabetical character and is not\n-- a part of a word, and false otherwise.\n-- Note: \"word\" is a group of characters separated by space.\n-- Examples:\n-- >>> check_if_last_char_is_a_letter('apple pie')\n-- false\n-- >>> check_if_last_char_is_a_letter('apple pi e')\n-- true\n-- >>> check_if_last_char_is_a_letter('apple pi e ')\n-- false\n-- >>> check_if_last_char_is_a_letter('')\n-- false\nlocal function check_if_last_char_is_a_letter(txt)\n  local last_char = txt:sub(-1)\n  local last_word = txt:match('%S+$')\n  if last_char:match('%a') and last_word:match('%a$') then\n    return true\n  else\n    return false\n  end\nend\n"], ["-- Create a function which returns the largest index of an element which\n-- is not greater than or equal to the element immediately preceding it. If\n-- no such element exists then return -1. The given table will not contain\n-- duplicate values.\n-- Examples:\n-- >>> can_arrange({1, 2, 4, 3, 5})\n-- 3\n-- >>> can_arrange({1, 2, 3})\n-- -1\nlocal function can_arrange(arr)\n  local max_index = -1\n  for i = 2, #arr do\n    if arr[i] < arr[i-1] then\n      max_index = i - 1\n    end\n  end\n  return max_index\nend"], ["-- Create a function that returns a table (a, b), where 'a' is\n-- the largest of negative integers, and 'b' is the smallest\n-- of positive integers in a table.\n-- If there is no negative or positive integers, return them as nil.\n-- Examples:\n-- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n-- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function largest_smallest_integers(lst)\n    local largest_negative = nil\n    local smallest_positive = nil\n    for _, num in ipairs(lst) do\n        if num < 0 and (largest_negative == nil or num > largest_negative) then\n            largest_negative = num\n        elseif num > 0 and (smallest_positive == nil or num < smallest_positive) then\n            smallest_positive = num\n        end\n    end\n    return {largest_negative, smallest_positive}\nend"], ["-- Create a function that takes integers, floats, or strings representing\n-- real numbers, and returns the larger variable in its given variable type.\n-- Return nil if the values are equal.\n-- Note: If a real number is represented as a string, the floating point might be . or ,\n-- >>> compare_one(1, 2.5)\n-- 2.5\n-- >>> compare_one(1, '2,3')\n-- '2,3'\n-- >>> compare_one('5,1', '6')\n-- '6'\n-- >>> compare_one('1', 1)\n-- None\nlocal function compare_one(a, b)\n    -- Convert strings to numbers if necessary\n    if type(a) == 'string' then\n        a = tonumber(string.gsub(a, ',', '.'))\n    end\n    if type(b) == 'string' then\n        b = tonumber(string.gsub(b, ',', '.'))\n    end\n    -- Compare the values\n    if a > b then\n        return a\n    elseif b > a then\n        return b\n    else\n        return nil\n    end\nend\n"], ["-- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n-- Example\n-- >>> is_equal_to_sum_even(4)\n-- false\n-- >>> is_equal_to_sum_even(6)\n-- false\n-- >>> is_equal_to_sum_even(8)\n-- true\nlocal function is_equal_to_sum_even(n)\n  if n % 2 ~= 0 then\n    return false\n  end\n  local sum = 0\n  for i = 1, n/2 do\n    sum = sum + i*2\n  end\n  return sum == n\nend"], ["-- The Brazilian factorial is defined as:\n-- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n-- where n > 0\n-- For example:\n-- >>> special_factorial(4)\n-- 288\n-- The function will receive an integer as input and should return the special\n-- factorial of this integer.\nlocal function special_factorial(n)\n  local result = 1\n  for i = n, 1, -1 do\n    result = result * i\n  end\n  return result\nend"], ["--  Return a greatest common divisor of two integers a and b\n-- >>> greatest_common_divisor(3, 5)\n-- 1\n-- >>> greatest_common_divisor(25, 15)\n-- 5\nlocal function greatest_common_divisor(a, b)\n  while b ~= 0 do\n    local temp = b\n    b = a % b\n    a = temp\n  end\n  return a\nend"], ["-- Given a string text, replace all spaces in it with underscores, \n-- and if a string has more than 2 consecutive spaces, \n-- then replace all consecutive spaces with - \n-- >>> fix_spaces(' Example')\n-- 'Example'\n-- >>> fix_spaces(' Example 1')\n-- 'Example_1'\n-- >>> fix_spaces(' Example 2')\n-- '_Example_2'\n-- >>> fix_spaces(' Example 3')\n-- '_Example-3'\nlocal function fix_spaces(text)\n  local new_text = string.gsub(text, \" \", \"_\")\n  new_text = string.gsub(new_text, \"__+\", \"-\")\n  return new_text\nend"], ["-- Create a function which takes a string representing a file's name, and returns\n-- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n-- A file's name is considered to be valid if and only if all the following conditions \n-- are met:\n-- - There should not be more than three digits ('0'-'9') in the file's name.\n-- - The file's name contains exactly one dot '.'\n-- - The substring before the dot should not be empty, and it starts with a letter from \n-- the latin alphapet ('a'-'z' and 'A'-'Z').\n-- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n-- Examples:\n-- >>> file_name_check('example.txt')\n-- 'Yes'\n-- >>> file_name_check('1example.dll')\n-- 'No'\nlocal function file_name_check(file_name)\n    -- Check if there are more than three digits in the file's name\n    if string.match(file_name, '%d%d%d%d') then\n        return 'No'\n    end"], ["-- \"\n-- This function will take a table of integers. For all entries in the table, the function shall square the integer entry if its index is a \n-- multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n-- change the entries in the table whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n-- Examples:\n-- >>> lst\n-- {1, 2, 3}\n-- >>> lst\n-- {}\n-- >>> lst\n-- {-1, -5, 2, -1, -5}\nlocal function sum_squares(lst)\n    local sum = 0\n    for i, num in ipairs(lst) do\n        if i % 3 == 0 then\n            sum = sum + num^2\n        elseif i % 4 == 0 then\n            sum = sum + num^3\n        else\n            sum = sum + num\n        end\n    end\n    return sum\nend\n"], ["-- You are given a string representing a sentence,\n-- the sentence contains some words separated by a space,\n-- and you have to return a string that contains the words from the original sentence,\n-- whose lengths are prime numbers,\n-- the order of the words in the new string should be the same as the original one.\n-- Example 1:\n-- >>> words_in_sentence('This is a test')\n-- 'is'\n-- Example 2:\n-- >>> words_in_sentence('lets go for swimming')\n-- 'go for'\n-- Constraints:\n--     * 1 <= len(sentence) <= 100\n--     * sentence contains only letters\nlocal function words_in_sentence(sentence)\n    local words = {}\n    for word in sentence:gmatch(\"%S+\") do\n        if is_prime(#word) then\n            table.insert(words, word)\n        end\n    end\n    return table.concat(words, \" \")\nend"], ["-- Your task is to implement a function that will simplify the expression\n-- x * n. The function returns true if x * n evaluates to a whole number and false\n-- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n-- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n-- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n-- >>> simplify('1/5', '5/1')\n-- true\n-- >>> simplify('1/6', '2/1')\n-- false\n-- >>> simplify('7/10', '10/2')\n-- false\nlocal function simplify(x, n)\n  local x_num, x_den = x:match(\"(%d+)/(%d+)\")\n  local n_num, n_den = n:match(\"(%d+)/(%d+)\")\n  local result = (x_num * n_num) / (x_den * n_den)\n  return result == math.floor(result)\nend"], ["-- Write a function which sorts the given table of integers\n-- in ascending order according to the sum of their digits.\n-- Note: if there are several items with similar sum of their digits,\n-- order them based on their index in original table.\n-- For example:\n-- >>> order_by_points({1, 11, -1, -11, -12})\n-- {-1, -11, 1, -12, 11}\n-- >>> order_by_points({})\n-- {}\nlocal function order_by_points(nums)\n    local function sum_digits(num)\n        local sum = 0\n        while num > 0 do\n            sum = sum + num % 10\n            num = math.floor(num / 10)\n        end\n        return sum\n    end\n    table.sort(nums, function(a, b)\n        local sum_a = sum_digits(math.abs(a))\n        local sum_b = sum_digits(math.abs(b))\n        if sum_a == sum_b then\n            return a < b\n        else\n            return sum_a < sum_b\n        end\n    end)\n    return nums\nend"], ["-- Write a function that takes a table of numbers as input and returns \n-- the number of elements in the table that are greater than 10 and both \n-- first and last digits of a number are odd (1, 3, 5, 7, 9).\n-- For example:\n-- >>> specialFilter({15, -73, 14, -15})\n-- 1\n-- >>> specialFilter({33, -2, -3, 45, 21, 109})\n-- 2\nlocal function specialFilter(nums)\n  local count = 0\n  for _, num in ipairs(nums) do\n    local firstDigit = math.abs(num) % 10\n    local lastDigit = math.abs(num) % 10\n    while math.abs(num) > 9 do\n      num = math.floor(math.abs(num) / 10)\n      lastDigit = math.abs(num) % 10\n    end\n    if num > 10 and firstDigit % 2 == 1 and lastDigit % 2 == 1 then\n      count = count + 1\n    end\n  end\n  return count\nend"], ["--     You are given a positive integer n. You have to create an integer table a of length n.\n-- For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n-- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n--     and a[i] + a[j] + a[k] is a multiple of 3.\n--     Example :\n--     >>> get_max_triples(5)\n--     1\n-- Explanation: \n-- a = [1, 3, 7, 13, 21]\n-- The only valid triple is (1, 7, 13).\nlocal function get_max_triples(n)\n    local a = {}\n    for i = 1, n do\n        a[i] = i * i - i + 1\n    end\n    local count = 0\n    for i = 1, n - 2 do\n        for j = i + 1, n - 1 do\n            for k = j + 1, n do\n                if (a[i] + a[j] + a[k]) % 3 == 0 then\n                    count = count + 1\n                end\n            end\n        end\n    end\n    return count\nend"], ["-- There are eight planets in our solar system: the closerst to the Sun \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n-- Uranus, Neptune.\n-- Write a function that takes two planet names as strings planet1 and planet2. \n-- The function should return a table containing all planets whose orbits are \n-- located between the orbit of planet1 and the orbit of planet2, sorted by \n-- the proximity to the sun. \n-- The function should return an empty table if planet1 or planet2\n-- are not correct planet names. \n-- Examples\n-- >>> bf('Jupiter', 'Neptune')\n-- {'Saturn', 'Uranus'}\n-- >>> bf('Earth', 'Mercury')\n-- 'Venus'\n-- >>> bf('Mercury', 'Uranus')\n-- {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'}\nlocal function bf(planet1, planet2)\n    local planets = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n    local index1 = table.indexof(planets, planet1)\n    local index2 = table.indexof(planets, planet2)\n    if index1 == nil or index2 == nil then\n        return {}\n    end\n    local result = {}\n    for i = index1 + 1, index2 - 1 do\n        table.insert(result, planets[i])\n    end\n    return result\nend"], ["-- Write a function that accepts a table of strings as a parameter,\n-- deletes the strings that have odd lengths from it,\n-- and returns the resulted table with a sorted order,\n-- The table is always a table of strings and never a table of numbers,\n-- and it may contain duplicates.\n-- The order of the table should be ascending by length of each word, and you\n-- should return the table sorted by that rule.\n-- If two words have the same length, sort the table alphabetically.\n-- The function should return a table of strings in sorted order.\n-- You may assume that all words will have the same length.\n-- For example:\n-- >>> list_sort({'aa', 'a', 'aaa'})\n-- {'aa'}\n-- >>> list_sort({'ab', 'a', 'aaa', 'cd'})\n-- {'ab', 'cd'}\nlocal function sorted_list_sum(lst)\n    local result = {}\n    for _, word in ipairs(lst) do\n        if #word % 2 == 0 then\n            table.insert(result, word)\n        end\n    end\n    table.sort(result, function(a, b)\n        if #a == #b then\n            return a < b\n        else\n            return #a < #b\n        end\n    end)\n    return result\nend"], ["--  Return table of all prefixes from shortest to longest of the input string\n-- >>> all_prefixes('abc')\n-- {'a', 'ab', 'abc'}\nlocal function all_prefixes(string)\n    local prefixes = {}\n    for i = 1, #string do\n        table.insert(prefixes, string:sub(1, i))\n    end\n    return prefixes\nend"], ["-- A simple program which should return the value of x if n is \n-- a prime number and should return the value of y otherwise.\n-- Examples:\n-- >>> x_or_y(7, 34, 12)\n-- 34\n-- >>> x_or_y(15, 8, 5)\n-- 5\nlocal function x_or_y(n, x, y)\n  local function is_prime(n)\n    if n <= 1 then\n      return false\n    end\n    for i = 2, math.sqrt(n) do\n      if n % i == 0 then\n        return false\n      end\n    end\n    return true\n  end\n  if is_prime(n) then\n    return x\n  else\n    return y\n  end\nend"], ["-- Given a table of numbers, return the sum of squares of the numbers\n-- in the table that are odd. Ignore numbers that are negative or not integers.\n-- >>> double_the_difference({1, 3, 2, 0})\n-- 10\n-- >>> double_the_difference({-1, -2, 0})\n-- 0\n-- >>> double_the_difference({9, -2})\n-- 81\n-- >>> double_the_difference({0})\n-- 0\n-- If the input table is empty, return 0.\nlocal function double_the_difference(lst)\n    local sum = 0\n    for _, num in ipairs(lst) do\n        if type(num) == \"number\" and num == math.floor(num) and num % 2 == 1 then\n            sum = sum + num * num\n        end\n    end\n    return sum\nend\n"], ["-- I think we all remember that feeling when the result of some long-awaited\n-- event is finally known. The feelings and thoughts you have at that moment are\n-- definitely worth noting down and comparing.\n-- Your task is to determine if a person correctly guessed the results of a number of matches.\n-- You are given two tables of scores and guesses of equal length, where each index shows a match. \n-- Return a table of the same length denoting how far off each guess was. If they have guessed correctly,\n-- the value is 0, and if not, the value is the absolute difference between the guess and the score.\n-- example:\n-- >>> compare({1, 2, 3, 4, 5, 1}, {1, 2, 3, 4, 2, -2})\n-- {0, 0, 0, 0, 3, 3}\n-- >>> compare({0, 5, 0, 0, 0, 4}, {4, 1, 1, 0, 0, -2})\n-- {4, 4, 1, 0, 0, 6}\nlocal function compare(game, guess)\n  local diff = {}\n  for i = 1, #game do\n    if game[i] == guess[i] then\n      diff[i] = 0\n    else\n      diff[i] = math.abs(game[i] - guess[i])\n    end\n  end\n  return diff\nend\n"], ["-- You will be given the name of a class (a string) and a table of extensions.\n-- The extensions are to be used to load additional classes to the class. The\n-- strength of the extension is as follows: Let CAP be the number of the uppercase\n-- letters in the extension's name, and let SM be the number of lowercase letters \n-- in the extension's name, the strength is given by the fraction CAP - SM. \n-- You should find the strongest extension and return a string in this \n-- format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions with the same strength, you should\n-- choose the one that comes first in the table.\n-- For example, if you are given \"Slices\" as the class and a table of the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n-- return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n-- (its strength is -1).\n-- Example:\n-- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})\n-- 'my_class.AA'\nlocal function Strongest_Extension(class_name, extensions)\n    local strongest_extension = ''\n    local strongest_strength = -1\n    for i, extension in ipairs(extensions) do\n        local cap_count = 0\n        local sm_count = 0\n        for j = 1, #extension do\n            local char = string.sub(extension, j, j)\n            if char == string.upper(char) then\n                cap_count = cap_count + 1\n            else\n                sm_count = sm_count + 1\n            end\n        end\n        local strength = cap_count - sm_count\n        if strength > strongest_strength then\n            strongest_extension = extension\n            strongest_strength = strength\n        end\n    end\n    return class_name .. '.' .. strongest_extension\nend\n"], ["-- You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n-- >>> cycpattern_check('abcd', 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup', 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef', 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal function cycpattern_check(a, b)\n  local n = #a\n  local m = #b\n  if m > n then return false end\n  local s = a .. a\n  for i = 1, n do\n    if s:sub(i, i + m - 1) == b then\n      return true\n    end\n  end\n  return false\nend\n"], ["-- Given an integer. return a table that has the number of even and odd digits respectively.\n-- Example:\n--     >>> even_odd_count(-12)\n--     {1, 1}\n--     >>> even_odd_count(123)\n--     {1, 2}\nlocal function even_odd_count(num)\n    local even_count = 0\n    local odd_count = 0\n    local abs_num = math.abs(num)\n    while abs_num > 0 do\n        local digit = abs_num % 10\n        if digit % 2 == 0 then\n            even_count = even_count + 1\n        else\n            odd_count = odd_count + 1\n        end\n        abs_num = math.floor(abs_num / 10)\n    end\n    return {even_count, odd_count}\nend"], ["-- Given a positive integer, obtain its roman numeral equivalent as a string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n-- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n-- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n  local roman_numerals = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals) do\n    while number >= pair[1] do\n      result = result .. pair[2]\n      number = number - pair[1]\n    end\n  end\n  return result:lower()\nend"], ["-- Given the lengths of the three sides of a triangle. Return true if the three\n-- sides form a right-angled triangle, false otherwise.\n-- A right-angled triangle is a triangle in which one angle is right angle or \n-- 90 degree.\n-- Example:\n-- >>> right_angle_triangle(3, 4, 5)\n-- true\n-- >>> right_angle_triangle(1, 2, 3)\n-- false\nlocal function right_angle_triangle(a, b, c)\n  local sides = {a, b, c}\n  table.sort(sides)\n  return sides[1]^2 + sides[2]^2 == sides[3]^2\nend"], ["-- Write a function that accepts a table of strings.\n-- The table contains different words. Return the word with maximum number\n-- of unique characters. If multiple strings have maximum number of unique\n-- characters, return the one which comes first in lexicographical order.\n-- >>> find_max({'name', 'of', 'string'})\n-- 'string'\n-- >>> find_max({'name', 'enam', 'game'})\n-- 'enam'\n-- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n-- 'aaaaaaa'\nlocal function find_max(words)\n  local max_word = ''\n  local max_unique = 0\n  for _, word in ipairs(words) do\n    local unique_chars = {}\n    for _, char in ipairs(word) do\n      unique_chars[char] = true\n    end\n    local num_unique = #unique_chars\n    if num_unique > max_unique or (num_unique == max_unique and word < max_word) then\n      max_word = word\n      max_unique = num_unique\n    end\n  end\n  return max_word\nend"], ["-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return a table of [ total number of eaten carrots after your meals,\n--                                 the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- >>> eat(5, 6, 10)\n-- {11, 4}\n-- >>> eat(4, 8, 9)\n-- {12, 1}\n-- >>> eat(1, 10, 10)\n-- {11, 0}\n-- >>> eat(2, 11, 5)\n-- {7, 0}\n-- Variables:\n-- @number : integer\n--     the number of carrots that you have eaten.\n-- @need : integer\n--     the number of carrots that you need to eat.\n-- @remaining : integer\n--     the number of remaining carrots thet exist in stock\n-- Constrain:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\nlocal function eat(number, need, remaining)\n    local eaten = number + need\n    local left = remaining - need\n    if left < 0 then\n        left = 0\n    end\n    return {eaten, left}\nend"], ["--  Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n-- >>> string_sequence(0)\n-- '0'\n-- >>> string_sequence(5)\n-- '0 1 2 3 4 5'\nlocal function string_sequence(n)\n  local result = \"\"\n  for i = 0, n do\n    result = result .. tostring(i) .. \" \"\n  end\n  return string.sub(result, 1, -2)\nend"], ["-- Given two tables operator, and operand. The first table has basic algebra operations, and \n-- the second table is a table of integers. Use the two given tables to build the algebric \n-- expression and return the evaluation of this expression.\n-- The basic algebra operations:\n-- Addition ( + ) \n-- Subtraction ( - ) \n-- Multiplication ( * ) \n-- Floor division ( // ) \n-- Exponentiation ( ** ) \n-- Example:\n-- operator['+', '*', '-']\n-- table = [2, 3, 4, 5]\n-- result = 2 + 3 * 4 - 5\n-- => result = 9\n-- Note:\n--     The length of operator table is equal to the length of operand table minus one.\n--     Operand is a table of of non-negative integers.\n--     Operator table has at least one operator, and operand table has at least two operands.\nlocal function do_algebra(operator, operand)\n    local result = operand[1]\n    for i = 1, #operator do\n        local op = operator[i]\n        local num = operand[i + 1]\n        if op == '+' then\n            result = result + num\n        elseif op == '-' then\n            result = result - num\n        elseif op == '*' then\n            result = result * num\n        elseif op == '//' then\n            result = math.floor(result / num)\n        elseif op == '**' then\n            result = result ^ num\n        end\n    end\n    return result\nend"], ["-- You are given a string s.\n-- if s[i] is a letter, reverse its case from lower to upper or vise versa, \n-- otherwise keep it as it is.\n-- If the string contains no letters, reverse the string.\n-- The function should return the resulted string.\n-- Examples\n-- >>> solve('1234')\n-- '4321'\n-- >>> solve('ab')\n-- 'AB'\n-- >>> solve('#a@C')\n-- '#A@c'\nlocal function solve(s)\n  local result = ''\n  local has_letters = false\n  for i = 1, #s do\n    local c = s:sub(i, i)\n    if c:match('%a') then\n      has_letters = true\n      if c:match('%l') then\n        result = result .. c:upper()\n      else\n        result = result .. c:lower()\n      end\n    else\n      result = result .. c\n    end\n  end\n  if not has_letters then\n    result = s:reverse()\n  end\n  return result\nend\n"], ["-- Given a string 'text', return its md5 hash equivalent string.\n-- If 'text' is an empty string, return nil.\n-- >>> string_to_md5('Hello world')\n-- '3e25960a79dbc69b674cd4ec67a72c62'\nlocal function string_to_md5(text)\n  if text == '' then\n    return nil\n  end\n  local md5 = require('md5')\n  return md5.sumhexa(text)\nend"], ["-- Given two positive integers a and b, return the even digits between a\n-- and b, in ascending order.\n-- For example:\n-- >>> generate_integers(2, 8)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(8, 2)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(10, 14)\n-- {}\nlocal function generate_integers(a, b)\n  local result = {}\n  for i = a, b do\n    local digits = {}\n    for digit in string.gmatch(tostring(i), \"%d\") do\n      table.insert(digits, tonumber(digit))\n    end\n    local even_digits = {}\n    for _, digit in ipairs(digits) do\n      if digit % 2 == 0 then\n        table.insert(even_digits, digit)\n      end\n    end\n    table.sort(even_digits)\n    for _, digit in ipairs(even_digits) do\n      table.insert(result, digit)\n    end\n  end\n  return result\nend"], ["--  Given a string, find out how many distinct characters (regardless of case) does it consist of\n-- >>> count_distinct_characters('xyzXYZ')\n-- 3\n-- >>> count_distinct_characters('Jerry')\n-- 4\nlocal function count_distinct_characters(string)\n  local seen = {}\n  local count = 0\n  for i = 1, #string do\n    local char = string:sub(i, i):lower()\n    if not seen[char] then\n      seen[char] = true\n      count = count + 1\n    end\n  end\n  return count\nend"], ["--  Input to this function is a string representing musical notes in a special ASCII format.\n-- Your task is to parse this string and return table of integers corresponding to how many beats does each\n-- not last.\n-- Here is a legend:\n-- 'o' - whole note, lasts four beats\n-- 'o|' - half note, lasts two beats\n-- '.|' - quater note, lasts one beat\n-- >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n-- {4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nlocal function parse_music(music_string)\n    local notes = {}\n    local current_note = \"\"\n    for i = 1, #music_string do\n        local char = music_string:sub(i, i)\n        if char == \" \" then\n            if current_note == \"o\" then\n                table.insert(notes, 4)\n            elseif current_note == \"o|\" then\n                table.insert(notes, 2)\n            elseif current_note == \".|\" then\n                table.insert(notes, 1)\n            end\n            current_note = \"\"\n        else\n            current_note = current_note .. char\n        end\n    end\n    return notes\nend"], ["--  Find how many times a given substring can be found in the original string. Count overlaping cases.\n-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa', 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string, substring)\n    local count = 0\n    local start_index = 1\n    while true do\n        local index = string.find(string, substring, start_index)\n        if index == nil then\n            break\n        end\n        count = count + 1\n        start_index = index + 1\n    end\n    return count\nend"], ["--  Input is a space-delimited string of numberals from 'zero' to 'nine'.\n-- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n-- Return the string with numbers sorted from smallest to largest\n-- >>> sort_numbers('three one five')\n-- 'one three five'\nlocal function sort_numbers(numbers)\n  local num_to_word = {\n    ['zero'] = 0,\n    ['one'] = 1,\n    ['two'] = 2,\n    ['three'] = 3,\n    ['four'] = 4,\n    ['five'] = 5,\n    ['six'] = 6,\n    ['seven'] = 7,\n    ['eight'] = 8,\n    ['nine'] = 9\n  }\n  local words = {}\n  for word in numbers:gmatch(\"%S+\") do\n    table.insert(words, word)\n  end\n  table.sort(words, function(a, b)\n    return num_to_word[a] < num_to_word[b]\n  end)\n  return table.concat(words, \" \")\nend"], ["--  Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n-- separate those group into separate strings and return the table of those.\n-- Separate groups are balanced (each open brace is properly closed) and not nested within each other\n-- Ignore any spaces in the input string.\n-- >>> separate_paren_groups('( ) (( )) (( )( ))')\n-- {'()', '(())', '(()())'}\nlocal function separate_paren_groups(paren_string)\n    local groups = {}\n    local current_group = ''\n    local open_count = 0\n    for i = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n        if char == '(' then\n            open_count = open_count + 1\n        elseif char == ')' then\n            open_count = open_count - 1\n        end\n        if open_count == 0 then\n            table.insert(groups, current_group)\n            current_group = ''\n        else\n            current_group = current_group .. char\n        end\n    end\n    return groups\nend"], ["--  From a supplied table of numbers (of length at least two) select and return two that are the closest to each\n-- other and return them in order (smaller number, larger number).\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n-- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n-- {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n    local closest_distance = math.huge\n    local closest_elements = {}\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n            local distance = math.abs(numbers[i] - numbers[j])\n            if distance < closest_distance then\n                closest_distance = distance\n                closest_elements = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    table.sort(closest_elements)\n    return closest_elements\nend"], ["--  Given table of numbers (of at least two elements), apply a linear transform to that table,\n-- such that the smallest number will become 0 and the largest will become 1\n-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25, 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n  local min_num = math.min(unpack(numbers))\n  local max_num = math.max(unpack(numbers))\n  local range = max_num - min_num\n  local rescaled_numbers = {}\n  for i, num in ipairs(numbers) do\n    rescaled_numbers[i] = (num - min_num) / range\n  end\n  return rescaled_numbers\nend"], ["--  Filter given table of any luathon values only for integers\n-- >>> filter_integers({'a', 3.14, 5})\n-- {5}\n-- >>> filter_integers({1, 2, 3, 'abc', {}, {}})\n-- {1, 2, 3}\nlocal function filter_integers(values)\n    local integers = {}\n    for i, value in ipairs(values) do\n        if type(value) == 'number' and value == math.floor(value) then\n            table.insert(integers, value)\n        end\n    end\n    return integers\nend"], ["--  Return length of given string\n-- >>> strlen('')\n-- 0\n-- >>> strlen('abc')\n-- 3\nlocal function strlen(string)\n  return #string\nend"], ["--  For a given number n, find the largest number that divides n evenly, smaller than n\n-- >>> largest_divisor(15)\n-- 5\nlocal function largest_divisor(n)\n  for i = n - 1, 1, -1 do\n    if n % i == 0 then\n      return i\n    end\n  end\nend"], ["--  Return table of prime factors of given integer in the order from smallest to largest.\n-- Each of the factors should be tableed number of times corresponding to how many times it appeares in factorization.\n-- Input number should be equal to the product of all factors\n-- >>> factorize(8)\n-- {2, 2, 2}\n-- >>> factorize(25)\n-- {5, 5}\n-- >>> factorize(70)\n-- {2, 5, 7}\nlocal function factorize(n)\n    local factors = {}\n    local i = 2\n    while i <= n do\n        if n % i == 0 then\n            table.insert(factors, i)\n            n = n / i\n        else\n            i = i + 1\n        end\n    end\n    return factors\nend"], ["--  From a table of integers, remove all elements that occur more than once.\n-- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates({1, 2, 3, 2, 4})\n-- {1, 3, 4}\nlocal function remove_duplicates(numbers)\n    local seen = {}\n    local result = {}\n    for _, num in ipairs(numbers) do\n        if not seen[num] then\n            table.insert(result, num)\n            seen[num] = true\n        end\n    end\n    return result\nend"], ["--  For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n-- >>> flip_case('Hello')\n-- 'hELLO'\nlocal function flip_case(string)\n  local result = ''\n  for i = 1, #string do\n    local char = string:sub(i, i)\n    if char:lower() == char then\n      result = result .. char:upper()\n    else\n      result = result .. char:lower()\n    end\n  end\n  return result\nend"], ["--  Concatenate table of strings into a single string\n-- >>> concatenate({})\n-- ''\n-- >>> concatenate({'a', 'b', 'c'})\n-- 'abc'\nlocal function concatenate(strings)\n  local result = ''\n  for _, s in ipairs(strings) do\n    result = result .. s\n  end\n  return result\nend"], ["--  Filter an input table of strings only for ones that start with a given prefix.\n-- >>> filter_by_prefix({}, 'a')\n-- {}\n-- >>> filter_by_prefix({'abc', 'bcd', 'cde', 'array'}, 'a')\n-- {'abc', 'array'}\nlocal function filter_by_prefix(strings, prefix)\n    local filtered = {}\n    for _, str in ipairs(strings) do\n        if str:sub(1, #prefix) == prefix then\n            table.insert(filtered, str)\n        end\n    end\n    return filtered\nend"], ["--  Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n  local integer_part = math.floor(number)\n  local decimal_part = number - integer_part\n  return decimal_part\nend"], ["-- Return only positive numbers in the table.\n-- >>> get_positive({-1, 2, -4, 5, 6})\n-- {2, 5, 6}\n-- >>> get_positive({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- {5, 3, 2, 3, 9, 123, 1}\nlocal function get_positive(l)\n    local result = {}\n    for _, num in ipairs(l) do\n        if num > 0 then\n            table.insert(result, num)\n        end\n    end\n    return result\nend"], ["-- Return true if a given number is prime, and false otherwise.\n-- >>> is_prime(6)\n-- false\n-- >>> is_prime(101)\n-- true\n-- >>> is_prime(11)\n-- true\n-- >>> is_prime(13441)\n-- true\n-- >>> is_prime(61)\n-- true\n-- >>> is_prime(4)\n-- false\n-- >>> is_prime(1)\n-- false\nlocal function is_prime(n)\n  if n <= 1 then\n    return false\n  end\n  for i = 2, math.sqrt(n) do\n    if n % i == 0 then\n      return false\n    end\n  end\n  return true\nend"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n-- to the values of the corresponding indicies of l, but sorted.\n-- >>> sort_third({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_third({5, 6, 3, 4, 8, 9, 2})\n-- {2, 6, 3, 4, 8, 9, 5}\nlocal function sort_third(l)\n  local l_prime = {}\n  local third_values = {}\n  for i, v in ipairs(l) do\n    if i % 3 == 0 then\n      table.insert(third_values, v)\n    end\n  end\n  table.sort(third_values)\n  for i, v in ipairs(l) do\n    if i % 3 == 0 then\n      table.insert(l_prime, third_values[math.ceil(i/3)])\n    else\n      table.insert(l_prime, v)\n    end\n  end\n  return l_prime\nend"], ["-- Return sorted unique elements in a table\n-- >>> unique({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {0, 2, 3, 5, 9, 123}\nlocal function unique(l)\n    local seen = {}\n    local result = {}\n    for _, v in ipairs(l) do\n        if not seen[v] then\n            seen[v] = true\n            table.insert(result, v)\n        end\n    end\n    table.sort(result)\n    return result\nend"], ["-- Return maximum element in the table.\n-- >>> max_element({1, 2, 3})\n-- 3\n-- >>> max_element({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n-- 123\nlocal function max_element(l)\n    local m = l[1]\n    for i = 2, #l do\n        if l[i] > m then\n            m = l[i]\n        end\n    end\n    return m\nend"], ["-- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n-- >>> fizz_buzz(50)\n-- 0\n-- >>> fizz_buzz(78)\n-- 2\n-- >>> fizz_buzz(79)\n-- 3\nlocal function fizz_buzz(n)\n  local count = 0\n  for i = 1, n-1 do\n    if (i % 11 == 0 or i % 13 == 0) and tostring(i):find(\"7\") then\n      count = count + 1\n    end\n  end\n  return count\nend\n"], ["-- This function takes a table l and returns a table l' such that\n-- l' is identical to l in the odd indicies, while its values at the even indicies are equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even({1, 2, 3})\n-- {1, 2, 3}\n-- >>> sort_even({5, 6, 3, 4})\n-- {3, 6, 5, 4}\nlocal function sort_even(l)\n  local l_even = {}\n  for i = 2, #l, 2 do\n    table.insert(l_even, l[i])\n  end\n  table.sort(l_even)\n  local l_sorted = {}\n  for i = 1, #l do\n    if i % 2 == 0 then\n      table.insert(l_sorted, l_even[i/2])\n    else\n      table.insert(l_sorted, l[i])\n    end\n  end\n  return l_sorted\nend"], ["-- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n-- >>> prime_fib(1)\n-- 2\n-- >>> prime_fib(2)\n-- 3\n-- >>> prime_fib(3)\n-- 5\n-- >>> prime_fib(4)\n-- 13\n-- >>> prime_fib(5)\n-- 89\nlocal function prime_fib(n)\n  local fib = {1, 1}\n  local i = 2\n  while #fib < n do\n    fib[i+1] = fib[i] + fib[i-1]\n    i = i + 1\n  end\n  local prime = {}\n  for j = 1, #fib do\n    local is_prime = true\n    for k = 2, math.floor(math.sqrt(fib[j])) do\n      if fib[j] % k == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(prime, fib[j])\n    end\n  end\n  return prime[n]\nend"], ["--  You're given a table of deposit and withdrawal operations on a bank account that starts with\n-- zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n-- at that point function should return true. Otherwise it should return false.\n-- >>> below_zero({1, 2, 3})\n-- false\n-- >>> below_zero({1, 2, -4, 5})\n-- true\nlocal function below_zero(operations)\n  local balance = 0\n  for _, op in ipairs(operations) do\n    balance = balance + op\n    if balance < 0 then\n      return true\n    end\n  end\n  return false\nend"], ["-- triples_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are three distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> triples_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> triples_sum_to_zero({1, 3, -2, 1})\n-- true\n-- >>> triples_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> triples_sum_to_zero({2, 4, -5, 3, 9, 7})\n-- true\n-- >>> triples_sum_to_zero({1})\n-- false\nlocal function triples_sum_to_zero(l)\n  local n = #l\n  for i = 1, n-2 do\n    for j = i+1, n-1 do\n      for k = j+1, n do\n        if l[i] + l[j] + l[k] == 0 then\n          return true\n        end\n      end\n    end\n  end\n  return false\nend\n"], ["-- Imagine a road that's a perfectly straight infinitely long line.\n-- n cars are driving left to right;  simultaneously, a different set of n cars\n-- are driving right to left.   The two sets of cars start out being very far from\n-- each other.  All cars move in the same speed.  Two cars are said to collide\n-- when a car that's moving left to right hits a car that's moving right to left.\n-- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n-- in their trajectory as if they did not collide.\n-- This function outputs the number of such collisions.\nlocal function car_race_collision(n)\n    return n\nend\n"], ["-- Return table with elements incremented by 1.\n-- >>> incr_list({1, 2, 3})\n-- {2, 3, 4}\n-- >>> incr_list({5, 3, 5, 2, 3, 3, 9, 0, 123})\n-- {6, 4, 6, 3, 4, 4, 10, 1, 124}\nlocal function incr_list(l)\n  local new_l = {}\n  for i, v in ipairs(l) do\n    new_l[i] = v + 1\n  end\n  return new_l\nend"], ["-- pairs_sum_to_zero takes a table of integers as an input.\n-- it returns true if there are two distinct elements in the table that\n-- sum to zero, and false otherwise.\n-- >>> pairs_sum_to_zero({1, 3, 5, 0})\n-- false\n-- >>> pairs_sum_to_zero({1, 3, -2, 1})\n-- false\n-- >>> pairs_sum_to_zero({1, 2, 3, 7})\n-- false\n-- >>> pairs_sum_to_zero({2, 4, -5, 3, 5, 7})\n-- true\n-- >>> pairs_sum_to_zero({1})\n-- false\nlocal function pairs_sum_to_zero(l)\n  local seen = {}\n  for _, x in ipairs(l) do\n    if seen[-x] then\n      return true\n    end\n    seen[x] = true\n  end\n  return false\nend\n"], ["-- Change numerical base of input number x to base.\n-- return string representation after the conversion.\n-- base numbers are less than 10.\n-- >>> change_base(8, 3)\n-- '22'\n-- >>> change_base(8, 2)\n-- '1000'\n-- >>> change_base(7, 2)\n-- '111'\nlocal function change_base(x, base)\n    local result = \"\"\n    while x > 0 do\n        local digit = x % base\n        result = tostring(digit) .. result\n        x = (x - digit) / base\n    end\n    return result\nend"], ["-- Given length of a side and high return area for a triangle.\n-- >>> triangle_area(5, 3)\n-- 7.5\nlocal function triangle_area(a, h)\n    return (a * h) / 2\nend"], ["-- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fib4(0) -> 0\n-- fib4(1) -> 0\n-- fib4(2) -> 2\n-- fib4(3) -> 0\n-- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n-- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n-- >>> fib4(5)\n-- 4\n-- >>> fib4(6)\n-- 8\n-- >>> fib4(7)\n-- 14\nlocal function fib4(n)\n  local fibs = {0, 0, 2, 0}\n  for i = 4, n do\n    fibs[i] = fibs[i-1] + fibs[i-2] + fibs[i-3] + fibs[i-4]\n  end\n  return fibs[n]\nend"], ["-- Return median of elements in the table l.\n-- >>> median({3, 1, 2, 4, 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n    local sorted = {}\n    for _, v in ipairs(l) do\n        table.insert(sorted, v)\n    end\n    table.sort(sorted)\n    local n = #sorted\n    if n % 2 == 1 then\n        return sorted[(n + 1) / 2]\n    else\n        return (sorted[n / 2] + sorted[n / 2 + 1]) / 2\n    end\nend"], ["-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- true\n-- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n-- >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n  local reversed = ''\n  for i = #text, 1, -1 do\n    reversed = reversed .. text:sub(i, i)\n  end\n  return text == reversed\nend"], ["-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n-- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  return (2^n) % p\nend\n"], ["--  For a given table of input numbers, calculate Mean Absolute Deviation\n-- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute difference between each\n-- element and a centerpoint (mean in this case):\n-- MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n-- 1.0\nlocal function mean_absolute_deviation(numbers)\n    local sum = 0\n    local count = 0\n    for _, number in ipairs(numbers) do\n        sum = sum + number\n        count = count + 1\n    end\n    local mean = sum / count\n    local mad_sum = 0\n    for _, number in ipairs(numbers) do\n        mad_sum = mad_sum + math.abs(number - mean)\n    end\n    return mad_sum / count\nend"], ["-- remove_vowels is a function that takes string and returns string without vowels.\n-- >>> remove_vowels('')\n-- ''\n-- >>> remove_vowels('abcdef')\n-- 'bcdf'\n-- >>> remove_vowels('aaaaa')\n-- ''\n-- >>> remove_vowels('aaBAA')\n-- 'B'\n-- >>> remove_vowels('zbcd')\n-- 'zbcd'\nlocal function remove_vowels(text)\n    local vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' }\n    local result = ''\n    for i = 1, #text do\n        local char = text:sub(i, i)\n        if not table.contains(vowels, char) then\n            result = result .. char\n        end\n    end\n    return result\nend"], ["-- Return true if all numbers in the table l are below threshold t.\n-- >>> below_threshold({1, 2, 4, 10}, 100)\n-- true\n-- >>> below_threshold({1, 20, 4, 10}, 5)\n-- false\nlocal function below_threshold(l, t)\n  for _, n in ipairs(l) do\n    if n >= t then\n      return false\n    end\n  end\n  return true\nend"], ["-- Add two numbers x and y\n-- >>> add(2, 3)\n-- 5\n-- >>> add(5, 7)\n-- 12\nlocal function add(x, y)\n  return x + y\nend"], ["-- Check if two words have the same characters.\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n-- true\n-- >>> same_chars('abcd', 'dddddddabc')\n-- true\n-- >>> same_chars('dddddddabc', 'abcd')\n-- true\n-- >>> same_chars('eabcd', 'dddddddabc')\n-- false\n-- >>> same_chars('abcd', 'dddddddabce')\n-- false\n-- >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n-- false\nlocal function same_chars(s0, s1)\n  local t0 = {}\n  local t1 = {}\n  for i = 1, #s0 do\n    t0[s0:sub(i, i)] = (t0[s0:sub(i, i)] or 0) + 1\n  end\n  for i = 1, #s1 do\n    t1[s1:sub(i, i)] = (t1[s1:sub(i, i)] or 0) + 1\n  end\n  for k, v in pairs(t0) do\n    if t1[k] ~= v then\n      return false\n    end\n  end\n  for k, v in pairs(t1) do\n    if t0[k] ~= v then\n      return false\n    end\n  end\n  return true\nend\n"], ["-- Return n-th Fibonacci number.\n-- >>> fib(10)\n-- 55\n-- >>> fib(1)\n-- 1\n-- >>> fib(8)\n-- 21\nlocal function fib(n)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 1\n  else\n    local a, b = 0, 1\n    for i = 2, n do\n      local c = a + b\n      a = b\n      b = c\n    end\n    return b\n  end\nend"], ["--  brackets is a string of \"<\" and \">\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('<')\n-- false\n-- >>> correct_bracketing('<>')\n-- true\n-- >>> correct_bracketing('<<><>>')\n-- true\n-- >>> correct_bracketing('><<>')\n-- false\nlocal function correct_bracketing(brackets)\n  local count = 0\n  for i = 1, #brackets do\n    if brackets:sub(i, i) == \"<\" then\n      count = count + 1\n    else\n      count = count - 1\n      if count < 0 then\n        return false\n      end\n    end\n  end\n  return count == 0\nend\n"], ["-- Return true is table elements are monotonically increasing or decreasing.\n-- >>> monotonic({1, 2, 4, 20})\n-- true\n-- >>> monotonic({1, 20, 4, 10})\n-- false\n-- >>> monotonic({4, 1, 0, -10})\n-- true\nlocal function monotonic(l)\n    local increasing = true\n    local decreasing = true\n    for i = 2, #l do\n        if l[i] > l[i-1] then\n            decreasing = false\n        elseif l[i] < l[i-1] then\n            increasing = false\n        end\n    end\n    return increasing or decreasing\nend"], ["-- Return sorted unique common elements for two tables.\n-- >>> common({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121})\n-- {1, 5, 653}\n-- >>> common({5, 3, 2, 8}, {3, 2})\n-- {2, 3}\nlocal function common(l1, l2)\n    local common_elements = {}\n    for _, element in ipairs(l1) do\n        if l2[element] then\n            common_elements[element] = true\n        end\n    end\n    local sorted_common_elements = {}\n    for element in pairs(common_elements) do\n        table.insert(sorted_common_elements, element)\n    end\n    table.sort(sorted_common_elements)\n    return sorted_common_elements\nend"], ["-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n-- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n-- 2\nlocal function largest_prime_factor(n)\n  local factor = 2\n  while n % factor ~= 0 do\n    factor = factor + 1\n  end\n  if n == factor then\n    return factor\n  else\n    return largest_prime_factor(n / factor)\n  end\nend"], ["--  Insert a number 'delimeter' between every two consecutive elements of input table `numbers'\n-- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1, 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n    local result = {}\n    for i, number in ipairs(numbers) do\n        table.insert(result, number)\n        if i < #numbers then\n            table.insert(result, delimeter)\n        end\n    end\n    return result\nend\n"], ["-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n(30)\n-- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n-- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return sum\nend"], ["--  brackets is a string of \"(\" and \")\".\n-- return true if every opening bracket has a corresponding closing bracket.\n-- >>> correct_bracketing('(')\n-- false\n-- >>> correct_bracketing('()')\n-- true\n-- >>> correct_bracketing('(()())')\n-- true\n-- >>> correct_bracketing(')(()')\n-- false\nlocal function correct_bracketing(brackets)\n    local count = 0\n    for i = 1, #brackets do\n        if brackets:sub(i, i) == \"(\" then\n            count = count + 1\n        elseif brackets:sub(i, i) == \")\" then\n            count = count - 1\n        end\n        if count < 0 then\n            return false\n        end\n    end\n    return count == 0\nend\n"], ["--  xs represent coefficients of a polynomial.\n-- xs[0] + xs[1] * x + xs[2] * x^2 + ....\n--  Return derivative of this polynomial in the same form.\n-- >>> derivative({3, 1, 2, 4, 5})\n-- {1, 4, 12, 20}\n-- >>> derivative({1, 2, 3})\n-- {2, 6}\nlocal function derivative(xs)\n    local result = {}\n    for i = 1, #xs - 1 do\n        table.insert(result, i * xs[i])\n    end\n    return result\nend"], ["-- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n-- fibfib(0) == 0\n-- fibfib(1) == 0\n-- fibfib(2) == 1\n-- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n-- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n-- >>> fibfib(1)\n-- 0\n-- >>> fibfib(5)\n-- 4\n-- >>> fibfib(8)\n-- 24\nlocal function fibfib(n)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 0\n  elseif n == 2 then\n    return 1\n  else\n    local a, b, c = 0, 0, 1\n    for i = 3, n do\n      local d = a + b + c\n      a, b, c = b, c, d\n    end\n    return c\n  end\nend"], ["-- Write a function vowels_count which takes a string representing\n-- a word as input and returns the number of vowels in the string.\n-- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n-- vowel, but only when it is at the end of the given word.\n-- Example:\n-- >>> vowels_count('abcde')\n-- 2\n-- >>> vowels_count('ACEDY')\n-- 3\nlocal function vowels_count(s)\n  local count = 0\n  for i = 1, #s do\n    local c = string.lower(s:sub(i, i))\n    if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' then\n      count = count + 1\n    end\n  end\n  return count\nend"], ["-- Circular shift the digits of the integer x, shift the digits right by shift\n-- and return the result as a string.\n-- If shift > number of digits, return digits reversed.\n-- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12, 2)\n-- '12'\nlocal function circular_shift(x, shift)\n  local digits = {}\n  while x > 0 do\n    table.insert(digits, 1, x % 10)\n    x = math.floor(x / 10)\n  end\n  if shift > #digits then\n    shift = #digits\n  end\n  local shifted_digits = {}\n  for i = 1, #digits do\n    local index = (i + shift - 1) % #digits + 1\n    table.insert(shifted_digits, digits[index])\n  end\n  return table.concat(shifted_digits)\nend"], ["-- Task\n-- Write a function that takes a string as input and returns the sum of the upper characters only'\n-- ASCII codes.\n-- Examples:\n-- >>> digitSum('')\n-- 0\n-- >>> digitSum('abAB')\n-- 131\n-- >>> digitSum('abcCd')\n-- 67\n-- >>> digitSum('helloE')\n-- 69\n-- >>> digitSum('woArBld')\n-- 131\n-- >>> digitSum('aAaaaXa')\n-- 153\nlocal function digitSum(s)\n  local sum = 0\n  for i = 1, #s do\n    local c = string.byte(s, i)\n    if c >= 65 and c <= 90 then\n      sum = sum + c\n    end\n  end\n  return sum\nend\n"], ["-- In this task, you will be given a string that represents a number of apples and oranges \n-- that are distributed in a basket of fruit this basket contains \n-- apples, oranges, and mango fruits. Given the string that represents the total number of \n-- the oranges and apples and an integer that represent the total number of the fruits \n-- in the basket return the number of the mango fruits in the basket.\n-- for examble:\n-- >>> fruit_distribution('5 apples and 6 oranges', 19)\n-- 8\n-- >>> fruit_distribution('0 apples and 1 oranges', 3)\n-- 2\n-- >>> fruit_distribution('2 apples and 3 oranges', 100)\n-- 95\n-- >>> fruit_distribution('100 apples and 1 oranges', 120)\n-- 19\nlocal function fruit_distribution(s, n)\n  local apples, oranges = s:match(\"(%d+) apples and (%d+) oranges\")\n  local total_fruits = apples + oranges\n  return n - total_fruits\nend\n"], ["-- \"Given a table representing a branch of a tree that has non-negative integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The plucked node should be the node with the smallest even value.\n-- If multiple nodes with the same smallest even value are found return the node that has smallest index.\n-- The plucked node should be returned in a table, [ smalest_value, its index ],\n-- If there are no even values or the given table is empty, return [].\n-- Example 1:\n-- >>> pluck({4, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 2:\n-- >>> pluck({1, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest index.\n-- Example 3:\n-- >>> pluck({})\n-- {}\n-- Example 4:\n-- >>> pluck({5, 0, 3, 0, 4, 2})\n-- {0, 1}\n-- Explanation: 0 is the smallest value, but  there are two zeros,\n--              so we will choose the first zero, which has the smallest index.\n-- Constraints:\n--     * 1 <= nodes.length <= 10000\n--     * 0 <= node.value\nlocal function pluck(arr)\n    local smallest_even = math.huge\n    local smallest_index = -1\n    for i, v in ipairs(arr) do\n        if v % 2 == 0 and v < smallest_even then\n            smallest_even = v\n            smallest_index = i\n        end\n    end\n    if smallest_index == -1 then\n        return {}\n    else\n        return {smallest_even, smallest_index}\n    end\nend\n"], ["-- You are given a non-empty table of positive integers. Return the greatest integer that is greater than \n-- zero, and has a frequency greater than or equal to the value of the integer itself. \n-- The frequency of an integer is the number of times it appears in the table.\n-- If no such a value exist, return -1.\n-- Examples:\n-- >>> search({4, 1, 2, 2, 3, 1})\n-- 2\n-- >>> search({1, 2, 2, 3, 3, 3, 4, 4, 4})\n-- 3\n-- >>> search({5, 5, 4, 4, 4})\n-- -1\nlocal function search(lst)\n    local freq = {}\n    for _, num in ipairs(lst) do\n        freq[num] = (freq[num] or 0) + 1\n    end\n    for i = #lst, 1, -1 do\n        if freq[i] >= i then\n            return i\n        end\n    end\n    return -1\nend\n"], ["--  Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n-- For each of the group, output the deepest level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting while ((())) has three.\n-- >>> parse_nested_parens('(()()) ((())) () ((())()())')\n-- {2, 3, 1, 3}\nlocal function parse_nested_parens(paren_string)\n    local max_depth = 0\n    local current_depth = 0\n    local depths = {}\n    for i = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n        if char == '(' then\n            current_depth = current_depth + 1\n            if current_depth > max_depth then\n                max_depth = current_depth\n            end\n        elseif char == ')' then\n            current_depth = current_depth - 1\n        elseif char == ' ' then\n            table.insert(depths, max_depth)\n            max_depth = 0\n            current_depth = 0\n        end\n    end\n    table.insert(depths, max_depth)\n    return depths\nend"], ["-- Given table of integers, return table in strange order.\n-- Strange sorting, is when you start with the minimum value,\n-- then maximum of the remaining integers, then minimum and so on.\n-- Examples:\n-- >>> strange_sort_list({1, 2, 3, 4})\n-- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>> strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n    local sorted = {}\n    while #lst > 0 do\n        table.insert(sorted, table.remove(lst, 1))\n        if #lst > 0 then\n            local max_val = math.max(unpack(lst))\n            local max_idx = table.indexof(lst, max_val)\n            table.insert(sorted, table.remove(lst, max_idx))\n        end\n    end\n    return sorted\nend\n"], ["-- Given the lengths of the three sides of a triangle. Return the area of\n-- the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n-- Otherwise return -1\n-- Three sides make a valid triangle when the sum of any two sides is greater \n-- than the third side.\n-- Example:\n-- >>> triangle_area(3, 4, 5)\n-- 6.0\n-- >>> triangle_area(1, 2, 10)\n-- -1\nlocal function triangle_area(a, b, c)\n  if a + b > c and a + c > b and b + c > a then\n    local s = (a + b + c) / 2\n    local area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return math.floor(area * 100 + 0.5) / 100\n  else\n    return -1\n  end\nend"], ["-- Write a function that returns true if the object q will fly, and false otherwise.\n-- The object q will fly if it's balanced (it is a palindromic table) and the sum of its elements is less than or equal the maximum possible weight w.\n-- Example:\n-- >>> will_it_fly({1, 2}, 5)\n-- false\n-- # 1+2 is less than the maximum possible weight, but it's unbalanced.\n-- >>> will_it_fly({3, 2, 3}, 1)\n-- false\n-- # it's balanced, but 3+2+3 is more than the maximum possible weight.\n-- >>> will_it_fly({3, 2, 3}, 9)\n-- true\n-- # 3+2+3 is less than the maximum possible weight, and it's balanced.\n-- >>> will_it_fly({3}, 5)\n-- true\n-- # 3 is less than the maximum possible weight, and it's balanced.\nlocal function will_it_fly(q, w)\n  local sum = 0\n  for i = 1, #q do\n    sum = sum + q[i]\n  end\n  if sum > w then\n    return false\n  end\n  for i = 1, #q/2 do\n    if q[i] ~= q[#q-i+1] then\n      return false\n    end\n  end\n  return true\nend\n"], ["-- Given a table arr of integers, find the minimum number of elements that\n-- need to be changed to make the table palindromic. A palindromic table is a table that\n-- is read the same backwards and forwards. In one change, you can change one element to any other element.\n-- For example:\n-- >>> smallest_change({1, 2, 3, 5, 4, 7, 9, 6})\n-- 4\n-- >>> smallest_change({1, 2, 3, 4, 3, 2, 2})\n-- 1\n-- >>> smallest_change({1, 2, 3, 2, 1})\n-- 0\nlocal function smallest_change(arr)\n    local n = #arr\n    local count = 0\n    for i = 1, n/2 do\n        if arr[i] ~= arr[n-i+1] then\n            count = count + 1\n        end\n    end\n    return count\nend"], ["-- Write a function that accepts two tables of strings and returns the table that has \n-- total number of chars in the all strings of the table less than the other table.\n-- if the two tables have the same number of chars, return the first table.\n-- Examples\n-- >>> total_match({}, {})\n-- {}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'Hi'})\n-- {'hI', 'Hi'}\n-- >>> total_match({'hi', 'admin'}, {'hi', 'hi', 'admin', 'project'})\n-- {'hi', 'admin'}\n-- >>> total_match({'hi', 'admin'}, {'hI', 'hi', 'hi'})\n-- {'hI', 'hi', 'hi'}\n-- >>> total_match({'4'}, {'1', '2', '3', '4', '5'})\n-- {'4'}\nlocal function total_match(lst1, lst2)\n    local total1 = 0\n    local total2 = 0\n    for _, str in ipairs(lst1) do\n        total1 = total1 + #str\n    end\n    for _, str in ipairs(lst2) do\n        total2 = total2 + #str\n    end\n    if total1 < total2 then\n        return lst1\n    elseif total1 > total2 then\n        return lst2\n    else\n        return lst1\n    end\nend\n"], ["-- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n-- and false otherwise.\n-- Knowing that (a) is less then 100. \n-- Example:\n-- >>> is_multiply_prime(30)\n-- true\n-- 30 = 2 * 3 * 5\nlocal function is_multiply_prime(a)\n  local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n  local count = 0\n  for i = 1, #primes do\n    if a % primes[i] == 0 then\n      count = count + 1\n      a = a / primes[i]\n      if count == 3 then\n        return true\n      end\n    end\n  end\n  return false\nend"], ["-- Your task is to write a function that returns true if a number x is a simple\n-- power of n and false in other cases.\n-- x is a simple power of n if n**int=x\n-- For example:\n-- >>> is_simple_power(1, 4)\n-- true\n-- >>> is_simple_power(2, 2)\n-- true\n-- >>> is_simple_power(8, 2)\n-- true\n-- >>> is_simple_power(3, 2)\n-- false\n-- >>> is_simple_power(3, 1)\n-- false\n-- >>> is_simple_power(5, 3)\n-- false\nlocal function is_simple_power(x, n)\n  if x == 1 then\n    return true\n  end\n  local i = 1\n  while n^i <= x do\n    if n^i == x then\n      return true\n    end\n    i = i + 1\n  end\n  return false\nend\n"], ["-- Write a function that takes an integer a and returns true \n-- if this ingeger is a cube of some integer number.\n-- Note: you may assume the input is always valid.\n-- Examples:\n-- >>> iscube(1)\n-- true\n-- >>> iscube(2)\n-- false\n-- >>> iscube(-1)\n-- true\n-- >>> iscube(64)\n-- true\n-- >>> iscube(0)\n-- true\n-- >>> iscube(180)\n-- false\nlocal function iscube(a)\n  local cube_root = math.pow(math.abs(a), 1/3)\n  local rounded_cube_root = math.floor(cube_root + 0.5)\n  return rounded_cube_root * rounded_cube_root * rounded_cube_root == a\nend\n"], ["-- You have been tasked to write a function that receives \n-- a hexadecimal number as a string and counts the number of hexadecimal \n-- digits that are primes (prime number, or a prime, is a natural number \n-- greater than 1 that is not a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5, 7, \n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is always correct or empty string, \n-- and symbols A,B,C,D,E,F are always uppercase.\n-- Examples:\n-- >>> hex_key('AB')\n-- 1\n-- >>> hex_key('1077E')\n-- 2\n-- >>> hex_key('ABED1A33')\n-- 4\n-- >>> hex_key('123456789ABCDEF0')\n-- 6\n-- >>> hex_key('2020')\n-- 2\nlocal function hex_key(num)\n    local primes = {2, 3, 5, 7, 11, 13}\n    local count = 0\n    for i = 1, #num do\n        local digit = tonumber(num:sub(i, i), 16)\n        if primes[digit] then\n            count = count + 1\n        end\n    end\n    return count\nend\n"], ["-- You will be given a number in decimal form and your task is to convert it to\n-- binary format. The function should return a string, with each character representing a binary\n-- number. Each character in the string will be '0' or '1'.\n-- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n-- The extra characters are there to help with the format.\n-- Examples:\n-- >>> decimal_to_binary(15)\n-- 'db1111db'\n-- >>> decimal_to_binary(32)\n-- 'db100000db'\nlocal function decimal_to_binary(decimal)\n    local binary = \"\"\n    while decimal > 0 do\n        binary = tostring(decimal % 2) .. binary\n        decimal = math.floor(decimal / 2)\n    end\n    return \"db\" .. binary .. \"db\"\nend"], ["--  Filter an input table of strings only for ones that contain given substring\n-- >>> filter_by_substring({}, 'a')\n-- {}\n-- >>> filter_by_substring({'abc', 'bacd', 'cde', 'array'}, 'a')\n-- {'abc', 'bacd', 'array'}\nlocal function filter_by_substring(strings, substring)\n    local filtered = {}\n    for _, str in ipairs(strings) do\n        if string.find(str, substring) then\n            table.insert(filtered, str)\n        end\n    end\n    return filtered\nend\n"], ["-- You are given a string s.\n-- Your task is to check if the string is haplua or not.\n-- A string is haplua if its length is at least 3 and every 3 consecutive letters are distinct\n-- For example:\n-- >>> is_happy('a')\n-- false\n-- >>> is_happy('aa')\n-- false\n-- >>> is_happy('abcd')\n-- true\n-- >>> is_happy('aabb')\n-- false\n-- >>> is_happy('adb')\n-- true\n-- >>> is_happy('xyy')\n-- false\nlocal function is_happy(s)\n  if string.len(s) < 3 then\n    return false\n  end\n  for i = 1, string.len(s) - 2 do\n    if s:sub(i, i + 2):find('^%a%a%a$') == nil then\n      return false\n    end\n  end\n  return true\nend\n"], ["-- It is the last week of the semester and the teacher has to give the grades\n-- to students. The teacher has been making her own algorithm for grading.\n-- The only problem is, she has lost the code she used for grading.\n-- She has given you a table of GPAs for some students and you have to write \n-- a function that can output a table of letter grades using the following table:\n--          GPA       |    Letter grade\n--           4.0                A+\n--         > 3.7                A \n--         > 3.3                A- \n--         > 3.0                B+\n--         > 2.7                B \n--         > 2.3                B-\n--         > 2.0                C+\n--         > 1.7                C\n--         > 1.3                C-\n--         > 1.0                D+ \n--         > 0.7                D \n--         > 0.0                D-\n--           0.0                E\n-- Example:\n-- >>> grade_equation({4.0, 3, 1.7, 2, 3.5})\n-- {'A+', 'B', 'C-', 'C', 'A-'}\nlocal function numerical_letter_grade(grades)\n    local letter_grades = {}\n    for _, gpa in ipairs(grades) do\n        if gpa == 4.0 then\n            table.insert(letter_grades, \"A+\")\n        elseif gpa > 3.7 then\n            table.insert(letter_grades, \"A\")\n        elseif gpa > 3.3 then\n            table.insert(letter_grades, \"A-\")\n        elseif gpa > 3.0 then\n            table.insert(letter_grades, \"B+\")\n        elseif gpa > 2.7 then\n            table.insert(letter_grades, \"B\")\n        elseif gpa > 2.3 then\n            table.insert(letter_grades, \"B-\")\n        elseif gpa > 2.0 then\n            table.insert(letter_grades, \"C+\")\n        elseif gpa > 1.7 then\n            table.insert(letter_grades, \"C\")\n        elseif gpa > 1.3 then\n            table.insert(letter_grades, \"C-\")\n        elseif gpa > 1.0 then\n            table.insert(letter_grades, \"D+\")\n        elseif gpa > 0.7 then\n            table.insert(letter_grades, \"D\")\n        elseif gpa > 0.0 then\n            table.insert(letter_grades, \"D-\")\n        else\n            table.insert(letter_grades, \"E\")\n        end\n    end\n    return letter_grades\nend"], ["-- Write a function that takes a string and returns true if the string\n-- length is a prime number or false otherwise\n-- Examples\n-- >>> prime_length('Hello')\n-- true\n-- >>> prime_length('abcdcba')\n-- true\n-- >>> prime_length('kittens')\n-- true\n-- >>> prime_length('orange')\n-- false\nlocal function prime_length(string)\n  local length = string.len(string)\n  if length < 2 then\n    return false\n  end\n  for i = 2, math.sqrt(length) do\n    if length % i == 0 then\n      return false\n    end\n  end\n  return true\nend\n"], ["-- Given a positive integer n, return the count of the numbers of n-digit\n-- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n    if n == 1 then\n        return 1\n    else\n        return 2 * (10^(n-2))\n    end\nend\n"], ["-- Given a positive integer N, return the total sum of its digits in binary.\n-- Example\n-- >>> solve(1000)\n-- '1'\n-- >>> solve(150)\n-- '110'\n-- >>> solve(147)\n-- '1100'\n-- Variables:\n--     @N integer\n--          Constraints: 0 \u2264 N \u2264 10000.\n-- Output:\n--      a string of binary number\nlocal function solve(N)\n    local sum = 0\n    while N > 0 do\n        sum = sum + N % 2\n        N = math.floor(N / 2)\n    end\n    return string.format(\"%b\", sum)\nend\n"], ["-- Given a non-empty table of integers lst. add the even elements that are at odd indices..\n-- Examples:\n-- >>> add({4, 2, 6, 7})\n-- 2\nlocal function add(lst)\n    local sum = 0\n    for i = 1, #lst, 2 do\n        if lst[i] % 2 == 0 then\n            sum = sum + lst[i]\n        end\n    end\n    return sum\nend\n"], ["-- Write a function that takes a string and returns an ordered version of it.\n-- Ordered version of string, is a string where all words (separated by space)\n-- are replaced by a new word where all the characters arranged in\n-- ascending order based on ascii value.\n-- Note: You should keep the order of words and blank spaces in the sentence.\n-- For example:\n-- >>> anti_shuffle('Hi')\n-- 'Hi'\n-- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n-- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n  local words = {}\n  for word in s:gmatch(\"%S+\") do\n    local chars = {}\n    for char in word:gmatch(\".\") do\n      table.insert(chars, char)\n    end\n    table.sort(chars)\n    table.insert(words, table.concat(chars))\n  end\n  return table.concat(words, \" \")\nend"], ["-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1)\n-- {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\n-- >>> get_row({}, 1)\n-- {}\n-- >>> get_row({{}, {1}, {1, 2, 3}}, 3)\n-- {{2, 2}}\nlocal function get_row(lst, x)\n    local result = {}\n    for i, row in ipairs(lst) do\n        for j, val in ipairs(row) do\n            if val == x then\n                table.insert(result, {i - 1, j - 1})\n            end\n        end\n    end\n    table.sort(result, function(a, b)\n        if a[1] == b[1] then\n            return a[2] > b[2]\n        else\n            return a[1] < b[1]\n        end\n    end)\n    return result\nend\n"], ["-- Given a table of non-negative integers, return a colua of the given table after sorting,\n-- you will sort the given table in ascending order if the sum( first index value, last index value) is odd,\n-- or sort it in descending order if the sum( first index value, last index value) is even.\n-- Note:\n-- * don't change the given table.\n-- Examples:\n-- >>> sort_array({})\n-- {}\n-- >>> sort_array({5})\n-- {5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5})\n-- {0, 1, 2, 3, 4, 5}\n-- >>> sort_array({2, 4, 3, 0, 1, 5, 6})\n-- {6, 5, 4, 3, 2, 1, 0}\nlocal function sort_array(array)\n  local sum = array[1] + array[#array]\n  local sorted_array = {}\n  for _, value in ipairs(array) do\n    table.insert(sorted_array, value)\n  end\n  if sum % 2 == 0 then\n    table.sort(sorted_array, function(a, b) return a > b end)\n  else\n    table.sort(sorted_array)\n  end\n  return sorted_array\nend\n"], ["-- Create a function encrypt that takes a string as an argument and\n-- returns a string encrypted with the alphabet being rotated. \n-- The alphabet should be rotated in a manner such that the letters \n-- shift down by two multiplied to two places.\n-- For example:\n-- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n-- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal function encrypt(s)\n  local encrypted = ''\n  for i = 1, #s do\n    local c = string.byte(s, i)\n    if c >= 97 and c <= 122 then\n      c = c + 2*2\n      if c > 122 then\n        c = c - 26\n      end\n    end\n    encrypted = encrypted .. string.char(c)\n  end\n  return encrypted\nend\n"], ["--  For a given table of integers, return a table consisting of a sum and a product of all the integers in a table.\n-- Empty sum should be equal to 0 and empty product should be equal to 1.\n-- >>> sum_product({})\n-- {0, 1}\n-- >>> sum_product({1, 2, 3, 4})\n-- {10, 24}\nlocal function sum_product(numbers)\n    local sum = 0\n    local product = 1\n    for _, number in ipairs(numbers) do\n        sum = sum + number\n        product = product * number\n    end\n    return {sum, product}\nend"], ["-- You are given a table of integers.\n-- Write a function next_smallest() that returns the 2nd smallest element of the table.\n-- Return nil if there is no such element.\n-- >>> next_smallest({1, 2, 3, 4, 5})\n-- 2\n-- >>> next_smallest({5, 1, 4, 3, 2})\n-- 2\n-- >>> next_smallest({})\n-- None\n-- >>> next_smallest({1, 1})\n-- None\nlocal function next_smallest(lst)\n    local smallest = math.huge\n    local second_smallest = math.huge\n    for _, num in ipairs(lst) do\n        if num < smallest then\n            second_smallest = smallest\n            smallest = num\n        elseif num < second_smallest and num != smallest then\n            second_smallest = num\n        end\n    end\n    if second_smallest == math.huge then\n        return nil\n    else\n        return second_smallest\n    end\nend"], ["-- You'll be given a string of words, and your task is to count the number\n-- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences are delimited by '.', '?' or '!'.\n-- For example:\n-- >>> is_bored('Hello world')\n-- 0\n-- >>> is_bored('The sky is blue. The sun is shining. I love this weather')\n-- 1\nlocal function is_bored(S)\n  local count = 0\n  local sentence = ''\n  for i = 1, #S do\n    local c = S:sub(i, i)\n    if c == '.' or c == '?' or c == '!' then\n      if sentence:sub(1, 2) == 'I ' then\n        count = count + 1\n      end\n      sentence = ''\n    else\n      sentence = sentence .. c\n    end\n  end\n  return count\nend\n"], ["-- Create a function that takes 3 numbers.\n-- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n-- Returns false in any other cases.\n-- Examples\n-- >>> any_int(5, 2, 7)\n-- true\n-- >>> any_int(3, 2, 2)\n-- false\n-- >>> any_int(3, -2, 1)\n-- true\n-- >>> any_int(3.6, -2.2, 2)\n-- false\nlocal function any_int(x, y, z)\n  -- Check if all numbers are integers\n  if math.floor(x) == x and math.floor(y) == y and math.floor(z) == z then\n    -- Check if one of the numbers is equal to the sum of the other two\n    if x == y + z or y == x + z or z == x + y then\n      return true\n    end\n  end\n  return false\nend"], ["-- Write a function that takes a message, and encodes in such a \n-- way that it swaps case of all letters, replaces all vowels in \n-- the message with the letter that appears 2 places ahead of that \n-- vowel in the english alphabet. \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n-- >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local encoded = ''\n  for i = 1, #message do\n    local char = message:sub(i, i)\n    if char:lower() == char then\n      char = char:upper()\n    else\n      char = char:lower()\n    end\n    if vowels[char] then\n      local index = vowels[char] + 2\n      if index > 5 then\n        index = index - 5\n      end\n      char = vowels[index]\n    end\n    encoded = encoded .. char\n  end\n  return encoded\nend"], ["-- You are given a table of integers.\n-- You need to find the largest prime value and return the sum of its digits.\n-- Examples:\n-- >>> skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n-- 10\n-- >>> skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n-- 25\n-- >>> skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3})\n-- 13\n-- >>> skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6})\n-- 11\n-- >>> skjkasdkd({0, 81, 12, 3, 1, 21})\n-- 3\n-- >>> skjkasdkd({0, 8, 1, 2, 1, 7})\n-- 7\nlocal function skjkasdkd(lst)\n    local largest_prime = 0\n    for _, num in ipairs(lst) do\n        if num > largest_prime and is_prime(num) then\n            largest_prime = num\n        end\n    end\n    local sum_of_digits = 0\n    while largest_prime > 0 do\n        sum_of_digits = sum_of_digits + largest_prime % 10\n        largest_prime = math.floor(largest_prime / 10)\n    end\n    return sum_of_digits\nend"], ["-- Given a table, return true if all keys are strings in lower \n-- case or all keys are strings in upper case, else return false.\n-- The function should return false is the given table is empty.\n-- Examples:\n-- >>> check_dict_case({['a'] = 'apple', ['b'] = 'banana'})\n-- true\n-- >>> check_dict_case({['a'] = 'apple', ['A'] = 'banana', ['B'] = 'banana'})\n-- false\n-- >>> check_dict_case({['a'] = 'apple', [8] = 'banana', ['a'] = 'apple'})\n-- false\n-- >>> check_dict_case({['Name'] = 'John', ['Age'] = '36', ['City'] = 'Houston'})\n-- false\n-- >>> check_dict_case({['STATE'] = 'NC', ['ZIP'] = '12345'})\n-- true\nlocal function check_dict_case(dict)\n  if next(dict) == nil then\n    return false\n  end\n  local is_lower = true\n  local is_upper = true\n  for k, v in pairs(dict) do\n    if type(k) ~= 'string' then\n      return false\n    end\n    if not k:match('^[a-z]+$') then\n      is_lower = false\n    end\n    if not k:match('^[A-Z]+$') then\n      is_upper = false\n    end\n  end\n  return is_lower or is_upper\nend\n"], ["-- Implement a function that takes an non-negative integer and returns a table of the first n\n-- integers that are prime numbers and less than n.\n-- for example:\n-- >>> count_up_to(5)\n-- {2, 3}\n-- >>> count_up_to(11)\n-- {2, 3, 5, 7}\n-- >>> count_up_to(0)\n-- {}\n-- >>> count_up_to(20)\n-- {2, 3, 5, 7, 11, 13, 17, 19}\n-- >>> count_up_to(1)\n-- {}\n-- >>> count_up_to(18)\n-- {2, 3, 5, 7, 11, 13, 17}\nlocal function count_up_to(n)\n  local primes = {}\n  for i = 2, n do\n    local is_prime = true\n    for j = 2, math.sqrt(i) do\n      if i % j == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(primes, i)\n    end\n  end\n  return primes\nend\n"], ["-- Complete the function that takes two integers and returns \n-- the product of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n-- >>> multiply(148, 412)\n-- 16\n-- >>> multiply(19, 28)\n-- 72\n-- >>> multiply(2020, 1851)\n-- 0\n-- >>> multiply(14, -15)\n-- 20\nlocal function multiply(a, b)\n  local unit_a = a % 10\n  local unit_b = b % 10\n  return unit_a * unit_b\nend"], ["-- Given a string s, count the number of uppercase vowels in even indices.\n-- For example:\n-- >>> count_upper('aBCdEf')\n-- 1\n-- >>> count_upper('abcdefg')\n-- 0\n-- >>> count_upper('dBBE')\n-- 0\nlocal function count_upper(s)\n  local count = 0\n  for i = 1, #s, 2 do\n    local c = s:sub(i, i)\n    if c:match('[AEIOU]') then\n      count = count + 1\n    end\n  end\n  return count\nend"], ["-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n-- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n  local rounded = math.floor(num + 0.5)\n  if num > 0 and num - rounded == 0.5 then\n    return rounded + 1\n  elseif num < 0 and num - rounded == -0.5 then\n    return rounded - 1\n  else\n    return rounded\n  end\nend"], ["--  From a given table of integers, generate a table of rolling maximum element found until given moment\n-- in the sequence.\n-- >>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n-- {1, 2, 3, 3, 3, 4, 4}\nlocal function rolling_max(numbers)\n    local max_table = {}\n    local max_value = -math.huge\n    for i = 1, #numbers do\n        max_value = math.max(max_value, numbers[i])\n        table.insert(max_table, max_value)\n    end\n    return max_table\nend"]]